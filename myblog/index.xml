<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sakuya&#39;s Blog – Blog List</title>
    <link>https://perfsky.github.io/myblog/</link>
    <description>Recent content in Blog List on Sakuya&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 13 Apr 2025 23:11:58 +0800</lastBuildDate>
    
	  <atom:link href="https://perfsky.github.io/myblog/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>React Fiber流程简介</title>
      <link>https://perfsky.github.io/myblog/react-fiber-reconciliation/</link>
      <pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate>
      
      <guid>https://perfsky.github.io/myblog/react-fiber-reconciliation/</guid>
      <description>
        
        
        &lt;blockquote&gt;
  &lt;p&gt;摘自自己的前端笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;简要概括&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;简要概括&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e7%ae%80%e8%a6%81%e6%a6%82%e6%8b%ac&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;协调算法&lt;/strong&gt;是 React 在更新 UI 时的工作流程，目的是确定哪些部分的UI需要更新。React Fiber是React 16引入的新的&lt;strong&gt;协调算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 React 16 之前，组件树更新是通过递归方式进行的，称为&lt;strong&gt;堆栈调和（Stack Reconciliation）&lt;/strong&gt;，这种方式一旦开始&lt;strong&gt;无法中断&lt;/strong&gt;，直到&lt;strong&gt;遍历完整个组件树&lt;/strong&gt;。这种机制在处理大量数据或复杂视图时，可能导致&lt;strong&gt;主线程阻塞&lt;/strong&gt;，从而影响应用对用户输入和其他高优先级任务的响应。&lt;/p&gt;
&lt;p&gt;React Fiber 是对协调器的重写，完全向后兼容。React 的新协调算法被称为 Fiber Reconciler，主要目标是&lt;strong&gt;增量渲染&lt;/strong&gt;，优化 UI 动画、手势和用户交互响应性。它允许将&lt;strong&gt;工作分为多个块&lt;/strong&gt;，并将&lt;strong&gt;渲染分为多个帧&lt;/strong&gt;。此外，&lt;em&gt;Fiber&lt;/em&gt; 引入了&lt;strong&gt;优先级&lt;/strong&gt;、暂停、复用和中止工作的能力。&lt;em&gt;Fiber&lt;/em&gt; 可视为 React 自定义的&lt;strong&gt;带链接关系&lt;/strong&gt;的&lt;strong&gt;DOM 树&lt;/strong&gt;，每个 &lt;em&gt;Fiber&lt;/em&gt; 代表一个&lt;strong&gt;工作单元&lt;/strong&gt;，React 可根据剩余时间决定是否完成该工作，必要时可中断并恢复。&lt;/p&gt;
&lt;h2&gt;核心&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;核心&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%a0%b8%e5%bf%83&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Fiber 的&lt;strong&gt;核心特性&lt;/strong&gt;是&lt;strong&gt;中断和恢复&lt;/strong&gt;，这一特性大幅增强了 React 的&lt;strong&gt;并发&lt;/strong&gt;性和&lt;strong&gt;响应&lt;/strong&gt;性。&lt;/p&gt;
&lt;p&gt;React判断&lt;em&gt;Fiber&lt;/em&gt;是否有足够时间完成任务的机制是：检查任务优先级（用户输入/动画&amp;gt;非关键内容&amp;gt;懒加载）&lt;/p&gt;
&lt;h3&gt;中断&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;中断&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e4%b8%ad%e6%96%ad&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;可&lt;strong&gt;中断&lt;/strong&gt;的能力是React并发模式（Concurrent Mode）的核心，这种能力使得React可以优先处理高优先级的更新，而推迟低优先级的更新。（很复杂，但是类似OS的中断/挂起，会保存上下文等等）&lt;/p&gt;
&lt;h3&gt;增量渲染&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;增量渲染&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%a2%9e%e9%87%8f%e6%b8%b2%e6%9f%93&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;React将渲染任务分成每个&lt;em&gt;Fiber&lt;/em&gt;单元，包含组件状态、生命周期、DOM操作等信息。React按照&lt;em&gt;Fiber&lt;/em&gt;的优先级逐一执行&lt;/p&gt;
&lt;h2&gt;Fiber 的结构&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;fiber-的结构&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#fiber-%e7%9a%84%e7%bb%93%e6%9e%84&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一个 &lt;em&gt;Fiber&lt;/em&gt;（文章里用斜体&lt;em&gt;Fiber&lt;/em&gt;表示）是一个简单的 JavaScript 对象。它代表 React 元素或 DOM 树的一个节点。它是一个工作单位。相比之下，Fiber 是 React Fiber 的协调器。&lt;/p&gt;
&lt;p&gt;在第一次渲染时，React 会浏览每个 React 元素并创建一棵 &lt;em&gt;fibers&lt;/em&gt; 树。&lt;strong&gt;虽然我们称之为树，但 React Fiber 创建了一个节点的链表，其中每个节点都是一个 &lt;em&gt;fiber&lt;/em&gt;。&lt;/strong&gt; 并且在父、子和兄弟姐妹之间存在着一种关系。React 使用一个 &lt;em&gt;return&lt;/em&gt; 键来指向父节点，任何一个子 &lt;em&gt;fiber&lt;/em&gt; 在完成工作后都应该返回该节点；React也有指向子节点、兄弟节点的指针。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fiber&lt;/em&gt;节点的结构如下：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FiberNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;$FlowFixMe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;WorkTag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;pendingProps&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mixed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TypeOfMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 基本属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 描述此Fiber的启动模式的值（LegacyRoot = 0; ConcurrentRoot = 1）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// React key
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elementType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 描述React元素的类型。例如，对于JSX&amp;lt;App /&amp;gt;，elementType是App
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 组件类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stateNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 对于类组件，这是类的实例；对于DOM元素，它是对应的DOM节点。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// Fiber链接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 指向父Fiber
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 指向第一个子Fiber
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sibling&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 指向其兄弟Fiber
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子Fiber中的索引位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 如果组件上有ref属性，则该属性指向它
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;refCleanup&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 如果组件上的ref属性在更新中被删除或更改，此字段会用于追踪需要清理的旧ref
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Props &amp;amp; State
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pendingProps&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pendingProps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 正在等待处理的新props
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;memoizedProps&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 上一次渲染时的props
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;updateQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 一个队列，包含了该Fiber上的状态更新和副作用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;memoizedState&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 上一次渲染时的state
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dependencies&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 该Fiber订阅的上下文或其他资源的描述
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 工作模式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 描述Fiber工作模式的标志（例如Concurrent模式、Blocking模式等）。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// Effects
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NoFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 描述该Fiber发生的副作用的标志（十六进制的标识）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;subtreeFlags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NoFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 描述该Fiber子树中发生的副作用的标志（十六进制的标识）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;deletions&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 在commit阶段要删除的子Fiber数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lanes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NoLanes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 与React的并发模式有关的调度概念。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;childLanes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NoLanes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 与React的并发模式有关的调度概念。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;alternate&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Current Tree和Work-in-progress (WIP) Tree的互相指向对方tree里的对应单元
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果启用了性能分析
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;enableProfilerTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ……
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 开发模式中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;__DEV__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ……
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到每个节点都有自己的属性、元素类型、父子兄弟关系、状态和副作用。&lt;/p&gt;
&lt;p&gt;为什么&lt;em&gt;fiber&lt;/em&gt;比之前的递归DOM更快？就是因为使用flags标记当前节点和子树的副作用类型，减少节点遍历。并且调和过程可被中断。&lt;/p&gt;
&lt;h2&gt;建立阶段&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;建立阶段&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%bb%ba%e7%ab%8b%e9%98%b6%e6%ae%b5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;建立阶段确定哪些部分的UI需要更新，会比较当前的树&lt;em&gt;current&lt;/em&gt;和正在工作的树&lt;em&gt;workInProgress&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;当前被刷新用来渲染用户界面的树，被称为 &lt;em&gt;current&lt;/em&gt;，它用来渲染当前用户界面。每当有更新时，Fiber 会建立一个 &lt;em&gt;workInProgress&lt;/em&gt; 树，它是由 React 元素中已经更新数据创建的。React 在这个 &lt;em&gt;workInProgress&lt;/em&gt; 树上执行工作，并在下次渲染时使用这个更新的树。一旦这个 &lt;em&gt;workInProgress&lt;/em&gt; 树被渲染到用户界面上，它就成为 &lt;em&gt;current&lt;/em&gt; 树。&lt;/p&gt;
&lt;p&gt;两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断&lt;em&gt;fiber&lt;/em&gt;是否要更新，创建与标记更新节点&lt;/li&gt;
&lt;li&gt;收集副作用列表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././react-fiber-reconciliation/routine1.png&#34; title=&#34;更新渲染树&#34; alt=&#34;routine 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;更新渲染树&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././react-fiber-reconciliation/routine2.png&#34; title=&#34;Fiber树遍历&#34; alt=&#34;routine 2&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Fiber树遍历&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终的fiber树：&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././react-fiber-reconciliation/final.jpg&#34; title=&#34;最终结果&#34; alt=&#34;final tree&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;最终结果&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;更新阶段&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;更新阶段&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%9b%b4%e6%96%b0%e9%98%b6%e6%ae%b5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;对于每次更新，它都会建立一个 &lt;em&gt;workInProgress&lt;/em&gt; 树。它从根 &lt;em&gt;fiber&lt;/em&gt; 开始，遍历该树，直到叶子节点。与初始渲染阶段不同，它不会为每个 React 元素创建一个新的 &lt;em&gt;fiber&lt;/em&gt; 。它只是为该 React 元素使用预先存在的 &lt;em&gt;fiber&lt;/em&gt; ，并在更新阶段合并来自更新元素的新数据和 props。&lt;/p&gt;
&lt;p&gt;React Fiber 将更新划分为工作单元。它可以为每个工作单元分配优先级，并有能力暂停、重用或在不需要时中止工作单元。 React Fiber 将工作分为多个工作单位，也就是 &lt;em&gt;fiber&lt;/em&gt; 。它将工作安排在多个框架中，并使用来自 &lt;em&gt;requestIdleCallback&lt;/em&gt; 的 &lt;em&gt;deadline&lt;/em&gt; 。每个更新都有其优先级的定义，如动画，或用户输入的优先级高于从获取的数据中渲染项目的列表。Fiber 使用 &lt;em&gt;requestAnimationFrame&lt;/em&gt; 来处理优先级较高的更新，使用 &lt;em&gt;requestIdleCallback&lt;/em&gt; 处理优先级较低的更新。因此，在调度工作时，Fiber 检查当前更新的优先级和 &lt;em&gt;deadline&lt;/em&gt; （帧结束后的自由时间）。&lt;/p&gt;
&lt;p&gt;如果优先级高于待处理的工作，或者没有 &lt;em&gt;截止日期&lt;/em&gt; 或者截止日期尚未到达，Fiber 可以在一帧之后安排多个工作单元。而下一组工作单元会被带到更多的帧上。这就是使 Fiber 有可能暂停、重用和中止工作单元的原因。&lt;/p&gt;
&lt;h2&gt;渲染阶段&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;渲染阶段&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%b8%b2%e6%9f%93%e9%98%b6%e6%ae%b5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;开始&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;开始&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%bc%80%e5%a7%8b&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;workLoop会判断每个&lt;em&gt;fiber&lt;/em&gt;是否有待处理的工作，没有则跳过已经处理过的fiber。&lt;/p&gt;
&lt;p&gt;如果有子 &lt;em&gt;fiber&lt;/em&gt; ，&lt;em&gt;beginWork&lt;/em&gt;函数返回子 &lt;em&gt;fiber&lt;/em&gt; ，如果没有子 &lt;em&gt;fiber&lt;/em&gt; 则返回空。函数 &lt;em&gt;performUnitOfWork&lt;/em&gt; 持续迭代并调用子 &lt;em&gt;fiber&lt;/em&gt; ，直到叶节点到达。在叶子节点的情况下，&lt;em&gt;beginWork&lt;/em&gt; 返回 null，因为没有任何子节点，&lt;em&gt;performUnitOfWork&lt;/em&gt; 函数调用 &lt;em&gt;completeUnitOfWork&lt;/em&gt; 函数。现在让我们看看完善阶段。&lt;/p&gt;
&lt;h3&gt;完善&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;完善&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%ae%8c%e5%96%84&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;这个 &lt;em&gt;completeUnitOfWork&lt;/em&gt; 函数通过调用一个 &lt;em&gt;completeWork&lt;/em&gt; 函数来完成当前单位的工作。如果有的话，&lt;em&gt;completeUnitOfWork&lt;/em&gt; 会返回一个同级的 &lt;em&gt;fiber&lt;/em&gt; 来执行下一个工作单元，如果没有工作的话，则会完成 return(parent) &lt;em&gt;fiber&lt;/em&gt; 。这将一直持续到返回值为空，也就是说，直到它到达根节点。和 &lt;em&gt;beginWork&lt;/em&gt; 一样，&lt;em&gt;completeWork&lt;/em&gt; 也是一个发生实际工作的函数，而 &lt;em&gt;completeUnitOfWork&lt;/em&gt; 是用于迭代的。&lt;/p&gt;
&lt;p&gt;渲染阶段的结果会产生一个效果列表（副作用）。这些效果就像插入、更新或删除宿主组件的节点，或调用类组件节点的生命周期方法。这些 &lt;em&gt;fiber&lt;/em&gt; 被标记为各自的效果标签。&lt;/p&gt;
&lt;h3&gt;提交&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;提交&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%8f%90%e4%ba%a4&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在这里，&lt;em&gt;workInProgress&lt;/em&gt; 树成为 &lt;em&gt;current&lt;/em&gt; 树，因为它被用来渲染 UI。实际的 DOM 更新，如插入、更新、删除，以及对生命周期方法的调用或者更新相对应的引用 —— 发生在 effect 列表中的节点上。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;参考资料&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000044468085&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fiber架构的原理和工作模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7006612306809323533&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fiber简介（机翻）&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>从rAF()探究浏览器帧渲染流程</title>
      <link>https://perfsky.github.io/myblog/how-raf-and-frame-works/</link>
      <pubDate>Sun, 13 Apr 2025 00:00:00 +0000</pubDate>
      
      <guid>https://perfsky.github.io/myblog/how-raf-and-frame-works/</guid>
      <description>
        
        
        &lt;h2&gt;requestAnimationFrame()&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;requestanimationframe&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#requestanimationframe&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;MDN对&lt;code&gt;rAF()&lt;/code&gt;的解释：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt; 方法会告诉浏览器你希望执行一个动画。它要求浏览器在下一次重绘之前，调用用户提供的回调函数。对回调函数的调用频率通常与显示器的刷新率相匹配。最常见的刷新率是 60hz。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;window.cancelAnimationFrame(rafId)&lt;/code&gt;作用于&lt;code&gt;rAF()&lt;/code&gt;的返回值，取消回调函数执行操作。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt;。&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 是一次性的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 是一个宏任务。&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;requestId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;回调发生在时间:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// rAF执行的回调函数只有一个参数val，是上一帧渲染的结束时间戳
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;requestId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;requestAnimationFrame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;requestAnimationFrame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;cancelAnimationFrame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;requestId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;特点以及机制&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;特点以及机制&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e7%89%b9%e7%82%b9%e4%bb%a5%e5%8f%8a%e6%9c%ba%e5%88%b6&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;为什么使用&lt;code&gt;rAF()&lt;/code&gt;而不是&lt;code&gt;setTimeout()&lt;/code&gt;？&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;为什么使用raf而不是settimeout&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8raf%e8%80%8c%e4%b8%8d%e6%98%afsettimeout&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;计时精确，帧生成时间稳定&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;计时精确帧生成时间稳定&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e8%ae%a1%e6%97%b6%e7%b2%be%e7%a1%ae%e5%b8%a7%e7%94%9f%e6%88%90%e6%97%b6%e9%97%b4%e7%a8%b3%e5%ae%9a&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;帧生成时间指的是每个完整帧从开始到结束渲染的时间。一般情况下，帧生成时间要小于当前刷新率下每帧持续显示的时间，这样才能确保画面显示稳定。否则可能会导致画面操作卡顿不跟手等问题。&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././how-raf-and-frame-works/frame-time-unstable.png&#34; title=&#34;恼人的卡顿&#34; alt=&#34;unstable frame time&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;恼人的卡顿&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 的间隔时间由浏览器决定。浏览器内核监听显示器的VSync（垂直同步）信号，并自动同步频率，使&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 能够以精确的16.67ms触发回调（60帧的情况下）。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;setTimeout()&lt;/code&gt; 、&lt;code&gt;setInterval()&lt;/code&gt;等方法会受到JS事件队列执行的影响，每次触发回调的时长会发生抖动。&lt;/p&gt;
&lt;h4&gt;自带FPS Meter监控帧时长&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;自带fps-meter监控帧时长&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e8%87%aa%e5%b8%a6fps-meter%e7%9b%91%e6%8e%a7%e5%b8%a7%e6%97%b6%e9%95%bf&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;浏览器内部会使用&lt;code&gt;requestAnimationFrame()&lt;/code&gt; +高精度计时器记录帧生成时间、FPS、任务执行时间等数据，如果过长或者触发阈值，浏览器会延迟显示（导致FPS下降），或者主动跳过当前帧的渲染（更新状态但是不光栅化）。&lt;/p&gt;
&lt;h4&gt;页面处于后台或者元素不可见时暂停&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;页面处于后台或者元素不可见时暂停&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%a1%b5%e9%9d%a2%e5%a4%84%e4%ba%8e%e5%90%8e%e5%8f%b0%e6%88%96%e8%80%85%e5%85%83%e7%b4%a0%e4%b8%8d%e5%8f%af%e8%a7%81%e6%97%b6%e6%9a%82%e5%81%9c&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;为了提高性能和电池寿命，大多数浏览器都会暂停在后台选项卡或者隐藏的 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 中运行的 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;浏览器一帧的生命周期&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;浏览器一帧的生命周期&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%80%e5%b8%a7%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;简单来说，一个帧的完整生命周期如下：&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././how-raf-and-frame-works/life-of-a-frame.png&#34; title=&#34;简要步骤&#34; alt=&#34;life of a frame&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;简要步骤&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在主线程中处理输入、JS事件（包括同步和异步任务）&lt;/li&gt;
&lt;li&gt;由VSync信号驱动，检测是否需要更新页面，并触发一些系统事件&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 执行回调，这是动画系统最后的同步操作DOM的时机&lt;/li&gt;
&lt;li&gt;计算样式，处理Layout（回流）等内容&lt;/li&gt;
&lt;li&gt;计算/标记重绘部分，交给GPU或者渲染线程进行光栅化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;rAF()&lt;/code&gt; 在这里负责接受VSync同步信号，执行动画回调。&lt;/p&gt;
&lt;p&gt;而在Chromium文档中，一帧从开始到展现是如下的步骤：&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././how-raf-and-frame-works/chromium-frame.png&#34; title=&#34;分进程时序图&#34; alt=&#34;chromium&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;分进程时序图&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整个过程首先由四个进程组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Main Thread(blink): 主渲染进程，执行JS、布局和样式更新计算，把渲染树交给Layer Compositor&lt;/li&gt;
&lt;li&gt;Layer Compositor (cc): 渲染进程，负责合成层调度、调用光栅化线程、提交frame给Display Compositor&lt;/li&gt;
&lt;li&gt;Display Compositor: 副GPU进程，汇总Layer Compositor的frame，发起GPU绘制&lt;/li&gt;
&lt;li&gt;GPU Main: 真正执行GPU绘制、提出SwapBuffer请求，将buffer内容贴到屏幕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按顺序，分别会进行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Display Compositor发起帧准备，让Layer Compositor做层更新工作。&lt;/li&gt;
&lt;li&gt;Layer Compositor告知Main Thread进行计算样式/布局/重绘渲染树。&lt;/li&gt;
&lt;li&gt;Main Thread返回Render Tree给Layer Compositor。&lt;/li&gt;
&lt;li&gt;Layer Compositor等待光栅化完成（这一步可能在其他的线程甚至进程中），然后激活形成新的Layer Tree，等待直到GPU规定的提交deadline，再提交给Display Compositor。（这里，如果之前的工作耗时过长，处理管线可能会丢弃这一更新，导致丢帧）&lt;/li&gt;
&lt;li&gt;Display Compositor收集所有的CompositorFrame（和DidNotProduceFrame，如果丢帧），整合成单一的CompositorFrame。&lt;/li&gt;
&lt;li&gt;Display Compositor进行绘制操作（生成绘制命令），提交给GPU Main，请求交换Buffer。&lt;/li&gt;
&lt;li&gt;GPU Main等到上一个frame处理完成后再进行（硬件级）GPU绘制，使用Display Compositor的绘制命令进行绘制，绘制使用的是Chromium的Skia图形库记录的Deferred Display List。&lt;/li&gt;
&lt;li&gt;如果上一个frame还没有显示完，或者队列太满则会被阻塞，否则进行SwapBuffer请求（把已经画好的back buffer和当前显示的front buffer进行交换，双缓冲）&lt;/li&gt;
&lt;li&gt;交换完buffer之后，等待对齐下一个VSync再显示到显示器中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用流程图简化表示如下：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;VSync
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;↓
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GPU 进程（Display Compositor） → 渲染进程（Compositor Thread） → 渲染进程（Main Thread）做 JS/Layout
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;↓
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;渲染进程 LayerCompositor 栅格化 + 提交 frame
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;↓
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GPU 进程（汇总、绘制、Swap）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;↓
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;显示在屏幕上&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://chromium.googlesource.com/chromium/src/&amp;#43;/HEAD/docs/life_of_a_frame.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;拓展&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;拓展&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%8b%93%e5%b1%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;requestIdleCallback()&lt;/code&gt; 是浏览器提供的一种低优先级任务调度API，允许开发者在浏览器空闲时期执行其他任务。这里的浏览器空闲时期指的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前一帧渲染完成到后一帧开始渲染的间隔&lt;/li&gt;
&lt;li&gt;用户处于idle状态，并且没有任何动画执行的时期&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能保证任务在何时执行。如果渲染事件紧密，可能腾不出执行&lt;code&gt;rIC()&lt;/code&gt; 的时间。&lt;/li&gt;
&lt;li&gt;空闲回调时，任务执行的上限时间是&lt;code&gt;50ms&lt;/code&gt; ，目的是*”ensure responsiveness to new user input within the threshold of human perception”&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;*，防止用户突然操作感受到页面阻塞。&lt;/li&gt;
&lt;li&gt;兼容性不理想（Safari全版本不支持）；触发频率较低；早期SWR使用&lt;code&gt;rIC()&lt;/code&gt; 会和浏览器插件冲突。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;佚事&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;佚事&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e4%bd%9a%e4%ba%8b&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;其一&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;其一&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%85%b6%e4%b8%80&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;查阅资料时，发现早期浏览器对&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 的执行顺序不同，Chrome v71、Firefox等符合标准的浏览器会在style/layout/paint之前、JS事件循环之后触发回调，而IE、Edge、Safari则是在style/layout/paint之后触发。&lt;/p&gt;
&lt;p&gt;而HTML标准里，&lt;code&gt;requestAnimationFrame()&lt;/code&gt; 被规定在更新渲染中（即render下一帧之前）&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././how-raf-and-frame-works/html-standard.png&#34; title=&#34;HTML 标准&#34; alt=&#34;html standard&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;HTML 标准&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因此使用以下的代码，在标准下应该从左开始移动：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;querySelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;.test&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;testButton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getElementById&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;testButton&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resetButton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getElementById&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;resetButton&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;translate(0, 0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transition&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;none&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;testButton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addEventListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 重置状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transition&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;none&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 设置初始变换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;translate(400px, 0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;requestAnimationFrame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transition&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;transform 3s linear&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;translate(200px, 0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;resetButton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addEventListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transition&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;none&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;translate(0, 0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但是，在笔者的浏览器（较新的Safari+Chrome）上，均会从右向左移动，似乎把回调推迟到了下一帧，这就很奇怪了，可能是浏览器的优化策略所致。&lt;/p&gt;
&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././how-raf-and-frame-works/misfunction.gif&#34; title=&#34;标准下应该从左向右移动&#34; alt=&#34;msifunction&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;标准下应该从左向右移动&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/64917985&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;其二&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;其二&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%85%b6%e4%ba%8c&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;React 16.2.0弃用了&lt;code&gt;requestAnimationFrame()&lt;/code&gt; ，采用message event loop。不仅是因为上文中的回调时机问题，也是因为&lt;code&gt;MessageChannel&lt;/code&gt; 较为稳定，不会像&lt;code&gt;setTimeout()&lt;/code&gt; 一样有4ms的最小延迟，也不会像&lt;code&gt;requestAnimationFrame()&lt;/code&gt;一样触发事件受浏览器更新机制和VSync的影响。它既能及时让出主线程，又能够确保消息的稳定传递。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/react/pull/16214&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub PR&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kanglover.github.io/2024/09/19/react-requestIdleCallback/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://html.spec.whatwg.org/multipage/webappapis.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTML Standard 8.1.7.3 - 5.2.1 Note&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Hextra主题博客搭建指南</title>
      <link>https://perfsky.github.io/myblog/hextra-setup-tutorial/</link>
      <pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://perfsky.github.io/myblog/hextra-setup-tutorial/</guid>
      <description>
        
        
        &lt;blockquote&gt;
  &lt;p&gt;以Hextra主题为例的Hugo博客搭建指南&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;准备工作&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;准备工作&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装好Go和Hugo(extended version)&lt;/li&gt;
&lt;li&gt;配置好Git&lt;/li&gt;
&lt;li&gt;拥有一个域名(可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;速通&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;速通&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%80%9f%e9%80%9a&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div class=&#34;hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200&#34;&gt;
  &lt;div class=&#34;ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2&#34;&gt;&lt;div class=&#34;hx-select-none hx-text-xl&#34; style=&#34;font-family: &#39;Apple Color Emoji&#39;, &#39;Segoe UI Emoji&#39;, &#39;Segoe UI Symbol&#39;;&#34;&gt;ℹ️&lt;/div&gt;&lt;/div&gt;

  &lt;div class=&#34;hx-w-full hx-min-w-0 hx-leading-7&#34;&gt;
    &lt;div class=&#34;hx-mt-6 hx-leading-7 first:hx-mt-0&#34;&gt;施工中&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;建立两个仓库，分别存放源代码和生成的静态文件&lt;/li&gt;
&lt;li&gt;Hugo初始化博客，目标文件夹与源代码仓库同名&lt;/li&gt;
&lt;li&gt;拉取Hextra主题到./themes/hextra，拉取静态文件仓库到./public（使用&lt;code&gt;git submodule&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;配置hugo.yaml，参考exampleSite&lt;/li&gt;
&lt;li&gt;写一点东西&lt;/li&gt;
&lt;li&gt;生成静态文件，检查，推送到远程仓库&lt;/li&gt;
&lt;li&gt;配置Github Pages到静态文件仓库中&lt;/li&gt;
&lt;li&gt;(可选) CLoudflare 绑定域名解析&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一些容易踩的坑&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;一些容易踩的坑&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e4%b8%80%e4%ba%9b%e5%ae%b9%e6%98%93%e8%b8%a9%e7%9a%84%e5%9d%91&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;文件完整性校验不通过导致博客功能失效&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;文件完整性校验不通过导致博客功能失效&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%96%87%e4%bb%b6%e5%ae%8c%e6%95%b4%e6%80%a7%e6%a0%a1%e9%aa%8c%e4%b8%8d%e9%80%9a%e8%bf%87%e5%af%bc%e8%87%b4%e5%8d%9a%e5%ae%a2%e5%8a%9f%e8%83%bd%e5%a4%b1%e6%95%88&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
    &lt;figure&gt;
    &lt;img src=&#34;.././hextra-setup-tutorial/hextra-setup-tutorial_blocked-js-css.png&#34; title=&#34;如图&#34; alt=&#34;landscape&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;如图&lt;/figcaption&gt;
  &lt;/figure&gt;
为确保脚本或者样式表不被恶意篡改，网页会使用&lt;code&gt;integrity&lt;/code&gt;来校验文件完整性，如果计算的SHA-256值和指定的不匹配，则浏览器拒绝加载此资源。
而在hugo生成静态资源后，如果尝试将其上传到github，有可能文件中的换行符会被git自动转换，导致本地文件和云端文件校验值不同。
解决方法是关闭git自带的CRLF&amp;lt;&amp;ndash;&amp;gt;LF转换：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git config --global core.autocrlf false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;或者&lt;a href=&#34;https://docs.github.com/zh/get-started/getting-started-with-git/configuring-git-to-handle-line-endings#per-repository-settings&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指定某个仓库不转换&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Cloudflare Pages自动构建过程出错&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;cloudflare-pages自动构建过程出错&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#cloudflare-pages%e8%87%aa%e5%8a%a8%e6%9e%84%e5%bb%ba%e8%bf%87%e7%a8%8b%e5%87%ba%e9%94%99&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;暂时未找到解决方法，替代品是直接让它部署生成后的静态页面&lt;/p&gt;
&lt;h2&gt;参考资料&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;参考资料&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://imfing.github.io/hextra/zh-cn/docs/getting-started/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hextra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gohugo.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gohugo.org/doc/content/front-matter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;头部自定义参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/website/issues/25414&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>看了也不会的GDB CheatSheet</title>
      <link>https://perfsky.github.io/myblog/useless-gdb-cheatsheet/</link>
      <pubDate>Thu, 23 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://perfsky.github.io/myblog/useless-gdb-cheatsheet/</guid>
      <description>
        
        
        &lt;h2&gt;基本命令&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;基本命令&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;1. disassemble&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;1-disassemble&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#1-disassemble&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;输出当前函数的汇编代码&lt;/p&gt;
&lt;p&gt;默认为AT&amp;amp;T格式，用&lt;code&gt;set disassembly-flavor intel&lt;/code&gt;来改为Intel汇编格式&lt;/p&gt;
&lt;p&gt;可以用&lt;code&gt;layout asm&lt;/code&gt;，在上方代码区显示汇编码&lt;/p&gt;
&lt;h3&gt;2. run&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;2-run&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#2-run&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;run&lt;/code&gt;（简写r）开始执行程序，直到遇到断点停止。也可用Ctrl+C手动中断。执行过程再次使用run即可重启程序。&lt;/p&gt;
&lt;h3&gt;3. continue&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-continue&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-continue&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;触发断点或者用Ctrl+C中断后，用&lt;code&gt;continue&lt;/code&gt;（简写c）继续，程序会执行直到遇到另一个断点。&lt;/p&gt;
&lt;h3&gt;4. break&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;4-break&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#4-break&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;break&lt;/code&gt;（简写b）添加断点。&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;## 在函数名为functionname的入口处添加一个断点（比如main）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;break&lt;/span&gt; functionname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;## 在当前文件行号为LineNo处添加一个断点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;break&lt;/span&gt; LineNo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;## 在filename文件行号为LineNo处添加一个断点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;break&lt;/span&gt; filename:LineNo&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;5. tbreak&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;5-tbreak&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#5-tbreak&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tbreak&lt;/code&gt;和&lt;code&gt;break&lt;/code&gt;用法相同，不过用此命令添加的断点触发一次之后即被删除。&lt;/p&gt;
&lt;h3&gt;6. info break/enable/disable/delete&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;6-info-breakenabledisabledelete&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#6-info-breakenabledisabledelete&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;info break&lt;/code&gt;查看添加的所有断点&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enable/disable + 断点编号&lt;/code&gt;可启用/禁用断点。若不加编号，默认对所有断点进行处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;delete + 断点编号&lt;/code&gt;永久删除断点。若不加编号，默认对所有断点进行处理&lt;/p&gt;
&lt;h3&gt;7. backtrace/frame&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;7-backtraceframe&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#7-backtraceframe&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;backtrace (bt)&lt;/code&gt;查看当前线程的调用堆栈&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frame + 堆栈编号&lt;/code&gt;可切换到其他堆栈&lt;/p&gt;
&lt;h3&gt;8. list&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;8-list&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#8-list&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;list (l)&lt;/code&gt;查看当前断点附近的代码。一般显示断点前后10行代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list + [加号]&lt;/code&gt; 向下显示10行代码， list+[减号] 向上显示10行代码&lt;/p&gt;
&lt;h3&gt;9. print/ptype&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;9-printptype&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#9-printptype&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;print&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;print (p)&lt;/code&gt; 可方便输出/修改变量的值&lt;/p&gt;
&lt;p&gt;同时支持输出表达式（解引用*，算术+-*/，打印错误码对应文字信息&lt;code&gt;strerror(errno)&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print variable = value&lt;/code&gt; 即可修改变量的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print /format variable&lt;/code&gt; 指定输出格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ptype&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ptype variable&lt;/code&gt; 输出变量类型（支持结构体）&lt;/p&gt;
&lt;h3&gt;10. info/thread&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;10-infothread&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#10-infothread&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;info&lt;/code&gt;用于查看各种信息，比如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info thread&lt;/code&gt; 查看所有线程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info args&lt;/code&gt; 查看当前函数的参数值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thread + 线程编号&lt;/code&gt; 切换到指定线程&lt;/p&gt;
&lt;h3&gt;11. next/step/until/finish/return/jump&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;11-nextstepuntilfinishreturnjump&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#11-nextstepuntilfinishreturnjump&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;next (n)&lt;/code&gt;跳到下一行（单步步过step over，遵循代码逻辑）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;step (s)&lt;/code&gt;会进入函数内部（单步步入step into）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;until (u) + &amp;lt;lineno&amp;gt;&lt;/code&gt; 直接执行到行数停止&lt;/p&gt;
&lt;p&gt;&lt;code&gt;return &amp;lt;value&amp;gt;&lt;/code&gt; 直接让函数用value返回值返回&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jump &amp;lt;lineno/location&amp;gt;&lt;/code&gt; 直接跳到行数或者函数地址（不停止，需要自行设置断点）&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;GDB空行直接回车默认为执行最近一次的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;12. set args/show args&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;12-set-argsshow-args&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#12-set-argsshow-args&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在使用run命令之前，使用&lt;code&gt;set args&lt;/code&gt;命令行参数来指定.&lt;/p&gt;
&lt;p&gt;可以使用文件，也可以直接輸入參數。有空格可以用雙引號包裹起來。&lt;/p&gt;
&lt;p&gt;清除参数，用&lt;code&gt;set args&lt;/code&gt;不加参数即可&lt;/p&gt;
&lt;h3&gt;13. watch/display&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;13-watchdisplay&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#13-watchdisplay&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;watch监视一个变量或者一段内存，如果发生变化就会中断。会产生一个watch point 观察点（数据断点）&lt;/p&gt;
&lt;p&gt;display监视变量或者内存值，每次 gdb 中断下来都会自动输出这些被监视变量或内存的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nfo display&lt;/code&gt;查看当前已经监视了哪些值，使用&lt;code&gt;delete display&lt;/code&gt;清除全部被监视的变量，使用&lt;code&gt;delete display + 编号&lt;/code&gt;移除对指定变量的监视&lt;/p&gt;
&lt;h3&gt;14. dir&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;14-dir&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#14-dir&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;gcc/g++编译出来的可执行程序并不包含完整源码，在不同环境里调试时可能不能匹配，dir可以让被调试的可执行程序匹配源代码&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 加一个源文件路径到当前路径的前面,指定多个路径为源码目录，可以使用引号”:”&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dir SourcePath1:SourcePath2:SourcePath&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;show dir&lt;/code&gt;可以查看当前设置的源码路径&lt;/p&gt;
&lt;p&gt;dir不加参数则初始化搜索路径为空&lt;/p&gt;
&lt;h2&gt;参考&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;参考&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%8f%82%e8%80%83&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://cppguide.cn/pages/68d9ed/#_2-5-1-gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88%E5%92%8C%E8%AF%B4%E6%98%8E&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GDB常用命令详解——利用GDB调试Redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://quickref.cn/docs/gdb.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GDB 备忘清单 &amp;amp; gdb cheatsheet &amp;amp; Quick Reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sourceware.org/gdb/download/onlinedocs/refcard.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CheatSheet PDF&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
