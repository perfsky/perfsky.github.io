{"/about/":{"data":{"":" Student, learning CS with ❤. My GitHub Profile "},"title":"About Me"},"/blogs/":{"data":{"":"","#":"最近更新 WebShell Traffic Analysis CTF Misc Tools"},"title":"Blog List"},"/blogs/ctf-cheatsheet-traffic-analysis/":{"data":{"":" 三种WebShell的特征，供流量分析用，AWD也可以参考","冰蝎#冰蝎":"静态特征 php在代码中同样会存在eval或assert等字符特征：\n在asp中会在for循环进行一段异或处理，然后传入execute代码执行\n在jsp中则利用java的反射，所以会存在ClassLoader，getClass().getClassLoader()等字符特征\n2.0 秘钥协商 Cookie Accept https://zhuanlan.zhihu.com/p/571463343\n使用 aes 加密发起三次请求\n第一次请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的 第二次请求是为了获取 key， 第三次使用 key 的 aes 加密进行通信 请求包存在：Accept: text/html, image/gif, image/jpeg, ; q=.2, /; q=.2\n冰蝎在连接之前会发送一个GET请求，服务端如果正常会响应一个16位的字符串。其实冰蝎每一次连接请求都会向服务端发送一次GET请求获取16位的密钥，这16位的字符串就是密钥，在客户端和服务端的通信过程中使用密钥进行加密以达到免杀的目的，因此只要我们能在流量中发现这样特征的流量，便可以发现隐藏在流量中的冰蝎webshell。\n建立连接，传输payload\n建立连接后的cookie存在特征字符\n所有请求 Cookie的格式都为: Cookie: PHPSESSID=; path=/；\n3.0 UA定长 请求头 https://www.freebuf.com/articles/247009.html\n少了动态密钥的获取的请求，不再使用随机生成 key，改为取连接密码的 md5 前 16 位作为密钥 一次请求为判断是否可以建立连接，少了两次 get 获取冰蝎动态密钥的行为，第二次发送 phpinfo 等代码执行。去除了动态密钥协商机制，采用预共享密钥，全程无明文交互，密钥格式为md5(“admin”)[0:16]\n请求头 Pragma: no-cache Cache-Control: no-cache Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 // 或者 Cache-Control: no-cache Pragma: no-cache Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 User-Agent 内置16个UA头，比较老旧\nMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1 Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0 Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50 Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E) Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3) Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB7.0) Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1) Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) Mozilla/5.0 (Windows; U; Windows NT 6.1; ) AppleWebKit/534.12 (KHTML, like Gecko) Maxthon/3.0 Safari/534.12 Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0) Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3 SE 2.X MetaSr 1.0 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1 QQBrowser/6.9.11079.201 Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) QQBrowser/6.9.11079.201 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0) Contetnt-Length 命令执行时，请求包中content-length为5740或5720（可能会根据Java版本而改变）\n4.0 Accept/Content-Length/User-Agent https://www.freebuf.com/articles/network/345803.html\nHTTP头特征 Accept 头通常固定 Accept: application/json, text/javascript, */*; q=0.01 意思是浏览器可接受任何文件，但最倾向application/json 和 text/javascript。 Accept-Encoding: identity Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Content-Length 较大 Content-Length: 8244 作为辅助特征\n默认使用长连接 Connection: Keep-Alive\nContent-Type PHP站点：Content-type: Application/x-www-form-urlencoded\nASP站点：Content-type: Application/octet-stream\n可以把这个字段作为一个弱特征，辅助其他特征来检测\nUser-agent 冰蝎设置了10种User-Agent,每次连接shell时会随机选择一个进行使用。\n响应头字段 Set-Cookie: PHPSESSID=a59734f13f1fe73947e0b3b01ea2aabe; path=/ Pragma: no-cache 流量特征 默认密钥 默认时，所有冰蝎4.0 webshell都有e45e329feb5d925b 一串密钥。该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond\n端口 冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右，每连接一次，每建立一次新的连接，端口就依次增加。\nPHP webshell 中存在固定代码 $post=Decrypt(file_get_contents(\"php://input\")); eval($post); 固定的请求头和响应头\n请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M\n响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd","参考#参考":"知乎 - WebShell流量特征\n语雀 - Webshell相关知识","哥斯拉#哥斯拉":"静态特征 在默认脚本编码的情况下，\nphp、asp为普通的一句话木马 jsp会出现xc、pass字符和Java反射(ClassLoader，getClass().getClassLoader())，base64加解码等特征 动态特征 哥斯拉支持多种加密方式，采用了和冰蝎 2.0 类似的密钥交换方式。它的webshell需要动态生成，可以根据需求选择不同的加密方式。哥斯拉建立连接时会发起三次请求，第一次请求数据超级长，建立 session，第二三次请求确认连接\n请求中的Accept头（弱特征）是\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\n相应头中的Cache-Control头（弱特征）是\nCache-Control: no-store, no-cache, must-revalidate\nCookie的结尾有分号","菜刀#菜刀":"特征 菜刀的木马就是一句话木马\n2014 以前的版本，有的 php/jsp 都为明文传输，较好判断\n2016 后做了加密和混淆，但是有些关键函数还是没有被加密的，比如 /ini_set，z0，eval，assert等。 菜刀的$_POST也可能会被$_GET和$_REQUEST替代。\nPHP 请求包 UA中存在baidu或firefox\n请求体中存在eval，base64等特征，payload为base64编码，存在固定的编码串\n// base64 QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7 // decoded @ini_set(\"display_errors\",\"0\");@set_time_limit(0);if(PHP_VERSION\u003c'5.3.0'){@set_magic_quotes_runtime(0);};echo(\"X@Y\"); 同时可能存在部分未加密函数，比如z0、assert(用于拼接)等\n响应包 明文，格式为X@Y[响应内容]X@Y\nJSP 该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A\u0026z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=参数用来加入攻击载荷。\nASP 其中body流量进行URL解码后 其中特征点有如下三部分\n“Execute”，Execute函数用于执行传递的攻击payload，这是必不可少的，这个等同于php类中eval函数； OnError ResumeNext，这部分是大部分ASP客户端中必有的流量，能保证不管前面出任何错，继续执行以下代码。 Response.Write和Response.End是必有的，是来完善整个操作的。 ","蚁剑#蚁剑":"特征 木马文件官方提供了模板，一句话木马也可以用\nphp中使用assert，eval执行；asp 使用 execute，eval；jsp使用的是Java类加载（ClassLoader）,同时会带有base64编码解码等字符特征\n默认的蚁剑 shell，连接时会请求两次，其请求体只是经过 url 编码，其流量中也存在和蚁剑一样的代码 第一次请求，关闭报错和 magic_quotes，接下来去获取主机的信息 第二次请求，会把主机目录列出来\n请求头中User-Agent值是：antSword/*，也有可能是：Mozilla/5.0 (Windows NT ***) AppleWebKit/*** (KHTML, like Gecko) Chrome/***** Safari/****\nPHP 请求包 PHP类WebShell链接流量，其中body流量进行URL解码后为： 其中流量最中明显的特征为@ini_set(\"display_errors\",\"0\"); @set_time_limit(0)这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现。\n响应包 响应包的结果返回格式为：随机数+响应内容+随机数\n_0x......=，以 0x 开头的参数名。由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以_0x......=这种形式（下划线可替换为其他），以及dirname、get_current_user函数的字眼，后面为加密数据包\nASP body流量进行URL解码后为： 蚁剑针对ASP类的WebShell流量与菜刀的流量很像，其中特征也是相同，如OnError ResumeNext、Response.End、Response.Write，其中execute在蚁剑中被打断混淆了，变成了拼接形式Ex\"\u0026cHr(101)\u0026\"cute，同时该流量中也使用了eval参数，可以被认为明显特征。"},"title":"CTF CheatSheet之WebShell流量分析"},"/blogs/ctf-misc-tools/":{"data":{"":"","misc2#MISC^2":"前言 MISC题型多变而且工具繁杂，因此自己花时间整理了一份工具列表，以便日后参考用\n流畅地阅读这篇博客，你可能需要：\nPython2.7.18 + Python3.8 + 任何一个更高版本的Python，使用conda管理 Linux虚拟机，kali即可 流畅访问Google/GitHub等站点的网络 通用工具 PuzzleSolver 专为misc手打造的瑞士军刀(?)，整合了多种脚本（base，字频分析，png/bmp自动修复文件头，图片盲水印等等）的带GUI的工具 仓库：Github - PuzzleSolver\n[随波逐流]CTF编码工具 集成了绝大部分编码的解码/转换工具，有一键解码功能，简单题直接一把梭 官网\n010 Editor 功能强大的十六进制编辑工具，有文件模板功能，便于修改各种缺失文件头文件尾。\nbinwalk 一个分析文件并提取嵌入的文件和代码的工具，可以判断源文件中包含的隐藏文件种类 仓库：Github - binwalk 快速入门：\nbinwalk -e stego.zip #提取stego.zip steghide/stegseek steghide隐写和配套解密工具，配合rockyou.txt食用更佳 快速入门：\nstegseek [stegofile.jpg] [wordlist.txt] #用wordlist暴力破解stegofile stegseek --seed [stegofile.jpg] # 分析此文件是否包含steghide内容，包含多少隐藏内容，是如何加密的 CyberChef 赛博厨子，ctf编码神器，方便易用，可以下载本地离线使用 链接：官网\nCiphey 一个功能强大的ai全自动解密工具，输入密文后自动返回解密文本并指出加密方式（虽然不能百分百解出，但有时候试试会有奇效） 仓库：Github - Ciphet 快速入门：\nciphey -t \"put_encrypted_message_here\" ciphey -f encrypted_message.txt # 加上-q 直接给出结果 # 加上-g 只输出答案 图片隐写 Stegsolve 常用于LSB隐写分析/内容提取、GIF查看单帧\nSilentEye 分析bmp/wav中的隐写\nOurSecret 带密码的jpg隐写工具\nAcropalypse-Multi-Tool 一个基于CVE-2023-28303和CVE-2023-21036漏洞的工具，可用于恢复截图被裁剪掉的部分数据 仓库：Github - Acropalypse Multi Tool\nQR Research 二维码识别/补全软件，支持各种纠错等级和二维码种类\nQrScan 另一个二维码识别软件，特点是能批量识别并输出到csv文件中 仓库：Github - QrScan\nImageMagick/gaps 多功能图像处理工具，多用于拼图，先用ImageMagick把打乱的图像拼接，再使用gaps识别并自动整理 链接（ImageMagick）：Github - ImageMagick \u0026 官网 链接（gaps）：Github - gaps 快速入门：\nmagick.exe montage *.jpg -tile 22x2 -geometry 64x256+0+0 abc.jpg # 将目录里的jpg文件按顺序拼成x轴22块，y轴2块的图 ，每个图块的大小为64X512像素，输出文件为abc.jpg gaps run --image=img.png --size=xxx --save # size填拼图各块的长宽 # 额外参数： –generations # 遗传算法迭代次数，效果不好时适当改变 –population # 个体数量 文件隐写 wbs4.3open 带密码的pdf隐写工具\nAOPR Forensic Edition 文档密码破解工具，支持暴力、字典、掩码等，可利用VBA后门 一个可用的学习版链接：pcbeta\n音频隐写 Audacity 开源的音频编辑软件，可以可视化查看频谱、音轨，便于找出音频中的分析点\nDeepSound 2.0 带密码的wav隐写分析工具\nRX-SSTV 一个sstv识别工具，可将声音信息转为图像\nQSSTV linux上的sstv接收软件，特点是可以直接读取wav音频文件里的信息，免去了外放的困扰 仓库：Github - QSSTV\nmp3stego 正如其名，是一个命令行mp3隐写分析工具 链接：mp3stego\n压缩包分析 ZipCenOp zip伪加密修复 快速入门：\njava -jar ZipCenOp.jar r fake_encrypted.zip ARCHPR 暴力破解工具，支持掩码、字典、明文攻击等手段\nbkcrack zip明文攻击工具，和ARCHPR相比支持更多的参数 条件：1.ZipCrypto加密方式 2.已知其中某个完整的明文文件/已知明文的至少12个字节和偏移（其中又至少8字节要连续）\nhashcat 宇宙最强密码/哈希破解工具，支持多种系统，cpu/gpu/apu计算，支持多种hash算法，可破解rar、office文档、pdf等文件。\n流量分析 WireShark 抓包流量分析软件 快速入门：\nmac地址/ip/端口过滤 eth.addr==20:dc:e6:f3:78:cc //筛选MAC地址是20:dc:e6:f3:78:cc的数据包，包括源或者目的MAC地址\reth.src==20:dc:e6:f3:78:cc //源MAC地址是20:dc:e6:f3:78:cc\reth.dst==20:dc:e6:f3:78:cc //目的MAC地址是20:dc:e6:f3:78:cc\rip.addr==192.168.1.122 //筛选出IP地址是192.168.1.122的数据包，包括源IP地址或者目的IP地址\rip.src== 和ip.dst==同上\rtcp.port==80 //根据TCP端口筛选数据包，包括源端口或者目的端口\rtcp.dstport==80 //根据目的TCP端口筛选\rtcp.srcport==80 //根据源TCP端口筛选\rudp.port==4010 //根据UDP端口筛选数据包，包括源端口或者目的端口\rudp.srcport==4010 //根据源UDP端口筛选\rudp.dstport==4010 //根据目的UDP端口筛选 协议筛选 常见协议：udp，tcp，arp，icmp，smtp，pop，dns，ip，ssl，http，ftp，ssh\nhttp //过滤http流量\rhttp.request.method==GET/POST\rhttp.response\rhttp.response.code \u003e=400（包含错误码）\rhttp.response.phrase == “OK”（过滤响应中的phrase）\rhttp contains \"snapshot\" //过滤http头中含有指定字符\rhttp.server contains “snapshot” //过滤http头中server字段含有指定字符\rhttp.content_type == “text/html” //过滤content_type是text/html的http响应、post包\rhttp.content_encoding == “gzip” //过滤content_encoding是gzip的http包\rhttp.transfer_encoding == “chunked” //根据transfer_encoding过滤\rhttp.content_length == 279\rhttp.content_length_header == “279” //根据content_length的数值过滤\rhttp.server //过滤所有含有http头中含有server字段的数据包 也可参考：知乎 - Wireshark教程\nMISC^2 ntfsstreamseditor NTFS数据流隐写\nveracrypt 磁盘加密软件，可建立虚拟磁盘并利用密码或者密钥文件进行加密，支持各种加密算法\nCheat Engine 功能如其名，做一些游戏题的时候可以用这个走走捷径。 不要和带反作弊的游戏一起开\nbruteHASH 穷举指定格式的数据的HASH值，格式可以为：\n指定明文格式 不限定明文格式随机字符穷举 自定义穷举字符集 CTF 常见 HASH(MD4/MD5/SHA1) 设置 HASH 开头、结尾或包含字符串 ","前言#前言":"","压缩包分析#压缩包分析":"","图片隐写#图片隐写":"","文件隐写#文件隐写":"","流量分析#流量分析":"","通用工具#通用工具":"","音频隐写#音频隐写":""},"title":"CTF MISC常用工具集锦/使用方法简介"},"/blogs/hextra-setup-tutorial/":{"data":{"":"","一些容易踩的坑#一些容易踩的坑":"","准备工作#准备工作":"","参考资料#参考资料":" 以Hextra主题为例的Hugo博客搭建指南\n准备工作 安装好Go和Hugo(extended version) 配置好Git 拥有一个域名(可选) 速通 ℹ️ 施工中 建立两个仓库，分别存放源代码和生成的静态文件 Hugo初始化博客，目标文件夹与源代码仓库同名 拉取Hextra主题到./themes/hextra，拉取静态文件仓库到./public（使用git submodule） 配置hugo.yaml，参考exampleSite 写一点东西 生成静态文件，检查，推送到远程仓库 配置Github Pages到静态文件仓库中 (可选) CLoudflare 绑定域名解析 一些容易踩的坑 文件完整性校验不通过导致博客功能失效1 如图 为确保脚本或者样式表不被恶意篡改，网页会使用integrity来校验文件完整性，如果计算的SHA-256值和指定的不匹配，则浏览器拒绝加载此资源。 而在hugo生成静态资源后，如果尝试将其上传到github，有可能文件中的换行符会被git自动转换，导致本地文件和云端文件校验值不同。 解决方法是关闭git自带的CRLF\u003c–\u003eLF转换：\ngit config --global core.autocrlf false 或者指定某个仓库不转换\nCloudflare Pages自动构建过程出错 暂时未找到解决方法，替代品是直接让它部署生成后的静态页面\n参考资料 Hextra Hugo 头部自定义参数 Issue ↩︎","速通#速通":""},"title":"博客搭建指南"},"/blogs/hitctf2023-misc/":{"data":{"":"","misc1---leftover-file#MISC1 - leftover file":"","misc2---h1f1#MISC2 - H1F1":"MISC1 - leftover file There is traffic packet captured by engineers on the intranet on the controlled machine. Please analyze the traffic packet and obtain the flag.\n拿到一个捕获文件，有大量Modbus/TCP协议的流量，并且从192.168.181.132 \u003c–\u003e 192.168.181.5的最多。 应用过滤：(modbus) \u0026\u0026(ip.src==192.168.181.132)\u0026\u0026(modbus.func_code==3)，这个的意思是过滤modbus协议，ip来源为192.168.181.132，且功能码为读保持的流量。 追踪流没发现什么线索，最后发现每条流量的最后部分，都会有规律地刷新： 提取这一部分的字符串： GGQ?O@+())pA#VSebM`[J]XGZUDIDUZ] 用工具解密得到flag MISC2 - H1F1 Some audiophiles claim they can hear the difference between 320K mp3 and lossless audio. 无损听不出来，但是192k和320k的mp3还是很容易分辨的\n给了一首歌的flac和mp3版本，根据描述应该是让我们从两个音频的差别来找线索 首先用audition将其中一首反相，再和另外一首进行混音，预览页面可以看到频谱有异常部分，并且左右耳能听到规律性的“嘟”声。 猜测是二进制序列，把上面的部分（左声道）视为0，下面视为1，提取出二进制序列： 01001000010010010101010001000011010101000100011000110010001100000011001000110011011110110111100100110000011101010101111101001000011000010111011000110011010111110110011100110000011011000100010000110011011011100101111100110011011000010111001001010011010111110011001101100011001100000011001100110001001101000011000001100110011000010110001001100001001110010110001001100110001110000110010001111101 解码得到flag "},"title":"[HITCTF2023] MISC1\u00262 WP"},"/blogs/iscc2023-beijing-fin-misc/":{"data":{"":"","后话#后话":"考点 流量分析，TLS，二维码修复\n解题步骤 首先速览一遍帮帮小明.pcapng，发现里面的协议有IMAP和TLS，这部分可能有线索 打开统计-\u003e会话，TCP栏有两个终点为25端口的地址，追踪流量，是两次对话 发现一个压缩包 保存，发现有密码，里面是一个加密后的文件mosaic.bmp，用zipcenop排除了伪加密的可能性，所以密码应该在另一个tcp流中 发现一段明文，用的gb2312编码，用vscode打开： 害，怎么密码忘了呢，只能往后面慢慢找了 这里附件还给了tls-log.txt，猜测需要解密tls密文，在编辑——\u003e首选项——\u003eProtocols——\u003eTLS——\u003e(Pre)-Master-Secret log filename这里加入即可 最后在某个TLS流找到了密码cAn_yOU_hElp_mE 解压压缩包，得到图片mosaic.bmp 还好队友见过原题，直接把脚本放了上来，参数甚至一点没变就可以用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 import math import numpy as np from PIL import Image from numpy.lib import ndindex X, Y = 103, 137 N = 20 BOX_SIZE = 23 PIXEL_SIZE = 11 def set_pix(array, x, y, val): '''将图片数组 array 中第 (x, y) 个二维码格设为 val ''' x1 = x * PIXEL_SIZE x2 = (x+1) * PIXEL_SIZE y1 = y * PIXEL_SIZE y2 = (y+1) * PIXEL_SIZE array[x1:x2, y1:y2] = val # check box[i, j] def check(ar, i, j): '''判断图片数组 ar 生成的马赛克的第 (i, j) 个块是否要求的相符 即比较数组 ar 对应位置的平均值和马赛克数组的对应格 ''' x1 = X + i*BOX_SIZE x2 = X + (i+1)*BOX_SIZE y1 = Y + j*BOX_SIZE y2 = Y + (j+1)*BOX_SIZE # print('box:\\n', ar[x1:x2, y1:y2]) mean = ar[x1:x2, y1:y2].mean() return math.floor(mean) == mosaic[i, j] def set_pixels(ar, uncertains, t): for k, pos in enumerate(uncertains): color = ((t \u003e\u003e k) \u0026 1) * 255 set_pix(ar, pos[0], pos[1], color) def solve(): error = False # for every box in pixelated area. for (i, j) in np.ndindex(mosaic.shape): # 考虑马赛克的每个格子 (i, j)，在 ar 中起始坐标是 (x, y) x = X + i*BOX_SIZE y = Y + j*BOX_SIZE # 只有从 (px, py) 开始的 3x3 个二维码格子会影响这个马赛克格子 px = x // PIXEL_SIZE py = y // PIXEL_SIZE # 3x3 个格子中还不确定的位置 uncertains = [] for tx, ty in np.ndindex(3, 3): if not flags[px+tx, py+ty]: uncertains.append((px+tx, py+ty)) if len(uncertains) == 0: continue possibles = [] print(f'Try mosaic{(i, j)}, from pixel{(x, y)}, uncertains: {uncertains}') for t in range(2**len(uncertains)): '''遍历2^k种可能性''' # print('Try: {0:0{1}b}'.format(t, len(uncertains))) set_pixels(ar, uncertains, t) # 将 ar 对应位置按 t 的每一位设置为对应颜色 if check(ar, i, j): # 判断马赛克颜色是否正确，正确则加入可能性列表 possibles.append(t) if len(possibles) == 1: # 只有一种可能性，那么是正确答案 set_pixels(ar, uncertains, possibles[0]) for x, y in uncertains: flags[x, y] = True elif len(possibles) \u003e 1: # 多个可能就随便设一个，但是不标记为已经确定 set_pixels(ar, uncertains, possibles[0]) # 也可以用下面的方法，将所有可能性中颜色都相同的格子找出来，设置为确定的 # 这样可以大大增加能解出的格子数（从 81% 提升到 88%） # print(possibles) # a = np.bitwise_and.reduce(np.asarray(possibles)) # b = np.bitwise_or.reduce(np.asarray(possibles)) # c = np.bitwise_xor(a, b) # print(f'{c:0{len(uncertains)}b}') # for k, pos in enumerate(uncertains): # color = ((possibles[0] \u003e\u003e k) \u0026 1) * 255 # set_pix(ar, pos[0], pos[1], color) # if (c \u003e\u003e k) \u0026 1 == 0: # flags[pos[0], pos[1]] = True elif len(possibles) == 0 and len(uncertains) != 0: # 出现不明原因的错误 print(f'Error: [{i}, {j}]') error = True break if error: break print(f'Solved: [{i}, {j}]') return flags.sum() # 返回目前确定的格子数 im = Image.open('pixelated_qrcode.bmp') ar = np.asarray(im, dtype='uint8') # 在该数组上逐步恢复和试算二维码 mosaic = ar[X::BOX_SIZE, Y::BOX_SIZE][:N, :N].copy() # 马赛克每格的数据 solved = ar[::PIXEL_SIZE, ::PIXEL_SIZE] # 用于存放答案，开始取二维码每格左上角值 # 注意 solved 是个引用，所以修改 ar 会跟着变 flags = (solved == 0) | (solved == 255) # 如果某格是 0 或 255，已经能确定颜色 rd_corner = ar[PIXEL_SIZE-1::PIXEL_SIZE, PIXEL_SIZE-1::PIXEL_SIZE] # 二维码每格右下角 rd_flags = (rd_corner == 0) | (rd_corner == 255) # 按右下角能确定颜色的二维码格 for i, j in np.ndindex(flags.shape): # 按左上角和右下角边缘，将能够确定的格补全 if flags[i, j]: set_pix(ar, i, j, solved[i, j]) if rd_flags[i, j]: set_pix(ar, i, j, rd_corner[i, j]) flags = (solved == 0) | (solved == 255) # 更新已确定的位置 while True: # 如果有新的格子被推算出来，那么继续算，否则已经没得算了 num_ok = flags.sum() if solve() == num_ok: break solved_im = Image.fromarray(ar) solved_im.save('solved.bmp') print('CertainRate:', flags.sum() / flags.size) 解密后读取二维码即可\n后话 这次iscc线下真的有点抽象，关卡题打到12点还只有我们队解出来了这一题，其他队伍都是爆零，后来主办方延时到18点，结果还是没人解出来…awd也很难搞，开始3h的pwn和web私地都只有寥寥几队打进来，主办方看不下去了就开放了pwn私地，可惜当时也不会打其他队伍，就简单布防了一下，不过虽然没拿分但也没被打，还是保住了排名\n总的来说是难度偏大的一次线下。","考点#考点":"","解题步骤#解题步骤":""},"title":"[ISCC2023线下] MISC1 WP"},"/blogs/useless-gdb-cheatsheet/":{"data":{"":"","参考#参考":"基本命令 1. disassemble 输出当前函数的汇编代码\n默认为AT\u0026T格式，用set disassembly-flavor intel来改为Intel汇编格式\n可以用layout asm，在上方代码区显示汇编码\n2. run 用run（简写r）开始执行程序，直到遇到断点停止。也可用Ctrl+C手动中断。执行过程再次使用run即可重启程序。\n3. continue 触发断点或者用Ctrl+C中断后，用continue（简写c）继续，程序会执行直到遇到另一个断点。\n4. break 用break（简写b）添加断点。\n## 在函数名为functionname的入口处添加一个断点（比如main） break functionname ## 在当前文件行号为LineNo处添加一个断点 break LineNo ## 在filename文件行号为LineNo处添加一个断点 break filename:LineNo 5. tbreak tbreak和break用法相同，不过用此命令添加的断点触发一次之后即被删除。\n6. info break/enable/disable/delete info break查看添加的所有断点\nenable/disable + 断点编号可启用/禁用断点。若不加编号，默认对所有断点进行处理\ndelete + 断点编号永久删除断点。若不加编号，默认对所有断点进行处理\n7. backtrace/frame backtrace (bt)查看当前线程的调用堆栈\nframe + 堆栈编号可切换到其他堆栈\n8. list list (l)查看当前断点附近的代码。一般显示断点前后10行代码\nlist + [加号] 向下显示10行代码， list+[减号] 向上显示10行代码\n9. print/ptype print print (p) 可方便输出/修改变量的值\n同时支持输出表达式（解引用*，算术+-*/，打印错误码对应文字信息strerror(errno) ）\nprint variable = value 即可修改变量的值\nprint /format variable 指定输出格式\nptype ptype variable 输出变量类型（支持结构体）\n10. info/thread info用于查看各种信息，比如\ninfo thread 查看所有线程\ninfo args 查看当前函数的参数值\nthread + 线程编号 切换到指定线程\n11. next/step/until/finish/return/jump next (n)跳到下一行（单步步过step over，遵循代码逻辑）\nstep (s)会进入函数内部（单步步入step into）\nuntil (u) + \u003clineno\u003e 直接执行到行数停止\nreturn \u003cvalue\u003e 直接让函数用value返回值返回\njump \u003clineno/location\u003e 直接跳到行数或者函数地址（不停止，需要自行设置断点）\nGDB空行直接回车默认为执行最近一次的命令。\n12. set args/show args 在使用run命令之前，使用set args命令行参数来指定.\n可以使用文件，也可以直接輸入參數。有空格可以用雙引號包裹起來。\n清除参数，用set args不加参数即可\n13. watch/display watch监视一个变量或者一段内存，如果发生变化就会中断。会产生一个watch point 观察点（数据断点）\ndisplay监视变量或者内存值，每次 gdb 中断下来都会自动输出这些被监视变量或内存的值\nnfo display查看当前已经监视了哪些值，使用delete display清除全部被监视的变量，使用delete display + 编号移除对指定变量的监视\n14. dir gcc/g++编译出来的可执行程序并不包含完整源码，在不同环境里调试时可能不能匹配，dir可以让被调试的可执行程序匹配源代码\n# 加一个源文件路径到当前路径的前面,指定多个路径为源码目录，可以使用引号”:” dir SourcePath1:SourcePath2:SourcePath show dir可以查看当前设置的源码路径\ndir不加参数则初始化搜索路径为空\n参考 GDB常用命令详解——利用GDB调试Redis\nGDB 备忘清单 \u0026 gdb cheatsheet \u0026 Quick Reference\nCheatSheet PDF","基本命令#基本命令":""},"title":"看了也不会的GDB CheatSheet"},"/blogs/xihu2024-initial-misc/":{"data":{"":"","内存取证#内存取证":"","爆破#爆破":" easy raw! many passwords!\n内存取证 首先用volatility+mimikatz可以爆出windows账户密码das123admin321 vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 mimikatz 剪贴板中，有另一个密码DasrIa456sAdmIn987，用来解压mysecretfile.rar vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 clipboard mysecretfile用了veracrypt加密，需要另一个密码，所以继续找线索 搜索相关文件，可以发现pass.zip，并用dumpfiles提取 vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 filescan | grep -E ‘png|jpg|gif|zip|rar|7z|pdf|txt|doc’ vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000003df8b650 -D .\\\n爆破 图片末尾提取出加密压缩包，ARCHPR爆破得密码20240210，解压得到pass.txt，挂载之后有一个隐藏文件.xlsx，也要密码，试出来就是之前得到的账户密码das123admin321 打开发现第10行被隐藏了，flag就在其中"},"title":"[西湖论剑2024初赛] MISC3-easy_rawraw WriteUp"},"/misc/":{"data":{"":"","#":"一点想法 "},"title":"Misc"},"/misc/raspi-lakka-simulator-tutorial/":{"data":{"":"","做一些微小的工作#做一些微小的工作":" 🎮 Lakka原生支持有线无线手柄，以下内容均可使用一个手柄完成 进入系统界面后，使用手柄进入Wi-Fi，连接网络（需要和你的电脑在同一内网下），或者直接插网线，然后进入设置-\u003e服务，打开SSH和SAMBA协议；接下来在菜单-\u003e系统信息-\u003e网络信息界面查看本机ip地址192.168.x.x，记下来。\n适当超频以获得更好的性能 对于树莓派4b，将sd卡插入电脑后，在【？？？】盘根目录下的config.txt中增加以下参数即可：\n# overclock over_voltage=6 # 增加电压 arm_freq=2000 # CPU 频率，单位是 MHz，最高 2147 gpu_freq=750 # GPU 频率，单位是 MHz force_turbo=0 # 为确保安全，以动态频率运行 对于之前的机型，超频参数可以参考： 树莓派如何超频\n系统空间扩容 烧录后系统的可用空间会比实际的存储介质容量小，所以需要扩容。 拿到地址后用SSH连接，账号密码均为root，然后依次执行下列命令：\nsystemctl stop retroarch mv .config .config.bak mv .cache .cache.bak touch /storage/.please_resize_me sync reboot 正常情况下，系统会多次重启。喝杯水回来，重新打开SSH和SAMBA协议，再次用SSH连接，依次执行下列命令：\nsystemctl stop retroarch rm -fr .cache .config .kodi mv .config.bak .config mv .cache.bak .cache sync reboot 设置中文 Lakka自带中文翻译，但是自带的字体中文显示不全，所以要替换字体。可以直接使用系统自带的微软雅黑，文件后缀为.ttf 使用WinSCP，选择SCP协议，用相同的地址、账号密码登录，然后进入/tmp/assets/xmb/monochrome下，将原本的font.ttf重命名为font.ttf.bak，然后将准备的字体文件重命名为font.ttf，复制到这个目录下。 随后，进入设置，将语言改为中文即可。\n其他 Lakka可以折腾的地方很多，比如：\n系统音视频设置 控制器键位设置 第三方成就 各种模拟器的内部设置 远程联机 这一部分就留给读者自行探索了。\n⚠️ 建议先备份一份配置文件/storage/.config/retroarch/retroarch.cfg，不小心折腾炸了可以进SSH手动恢复 ","准备工作#准备工作":"需要准备的硬件 一台电脑，一个树莓派（最好pi3及以上），或任何能安装Linux的机器 sd卡（32g及以上），或者一块硬盘 输入输出设备（显示器、键盘或手柄） 流畅、能上外网的网络连接 需要准备的软件 Raspberry Pi Imager，用于烧录镜像 SSH工具，推荐Termius或者MobaXterm用于建立连接 WinSCP，用于网络传送文件到树莓派 参考网站 Lakka官网\n树莓派系统烧录工具\n个人常用的复古游戏资源站\nWinSCP","前言#前言":"最近有点心痒，总想着要折腾点东西，于是把吃灰两年多的树莓派4b翻了出来。正经 Linux 想必是带不动的，手头上又正好有几个psp游戏，于是便想着装个模拟器，在 RetroPie 和 Lakka 之间选了界面更美观的 Lakka。","后记#后记":"左边是LGBT，右边是玩家策划对立，2024年的游戏圈子属实不太安定。如果感到厌倦了，不妨把老游戏捡起来，那可是一座宝藏。","游戏启动#游戏启动！":"用WinSCP将游戏ROM放入/storage/roms/下（也可以用文件夹分类不同游戏机的游戏），然后在系统中选择导入-\u003e扫描文件夹页面，在这个目录下选择\u003c扫描此文件夹\u003e，等待片刻即可自动导入游戏。\n实际测试中，树莓派4b可以完美高分辨率模拟运行除PSP以外的各种主机，PSP也可以在低于1080p的分辨率下流畅运行。不过运行时发热量略大，需要使用铝散热片或者散热壳加上风扇，否则可能降频。","烧录系统#烧录系统":"在 Lakka 官网下载对应系统的镜像，并用 Raspberry Pi Imager 烧录，可以不用设置任何东西。烧录完成会有提示。（在非树莓派机器上烧录，请查阅其他资料）\n没什么问题的话，烧录完直接连接到树莓派上即可。插电开机，第一次启动会需要一些时间，稍等片刻。\nℹ️ 如果提示文件系统错误之类，属正常现象，等待120s后自动修复即可进入系统 "},"title":"在树莓派上运行怀旧游戏——Lakka模拟器部署教程"},"/thoughts/":{"data":{"":"","#":"俺寻思…… "},"title":"Thoughts"}}