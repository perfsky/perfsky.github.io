{"/about/":{"data":{"":" Student, learning CS with ❤. My GitHub Profile "},"title":"About Me"},"/matches/":{"data":{"":"","#":"最近更新 [强网2024初赛] MISC-谍影重重5.0 WriteUp CTF Misc Tools "},"title":"Matches"},"/matches/ctf-cheatsheet-traffic-analysis/":{"data":{"":" 三种WebShell的特征，供流量分析用，AWD也可以参考","冰蝎#冰蝎":"静态特征 php在代码中同样会存在eval或assert等字符特征：\n在asp中会在for循环进行一段异或处理，然后传入execute代码执行\n在jsp中则利用java的反射，所以会存在ClassLoader，getClass().getClassLoader()等字符特征\n2.0 秘钥协商 Cookie Accept https://zhuanlan.zhihu.com/p/571463343\n使用 aes 加密发起三次请求\n第一次请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的 第二次请求是为了获取 key， 第三次使用 key 的 aes 加密进行通信 请求包存在：Accept: text/html, image/gif, image/jpeg, ; q=.2, /; q=.2\n冰蝎在连接之前会发送一个GET请求，服务端如果正常会响应一个16位的字符串。其实冰蝎每一次连接请求都会向服务端发送一次GET请求获取16位的密钥，这16位的字符串就是密钥，在客户端和服务端的通信过程中使用密钥进行加密以达到免杀的目的，因此只要我们能在流量中发现这样特征的流量，便可以发现隐藏在流量中的冰蝎webshell。\n建立连接，传输payload\n建立连接后的cookie存在特征字符\n所有请求 Cookie的格式都为: Cookie: PHPSESSID=; path=/；\n3.0 UA定长 请求头 https://www.freebuf.com/articles/247009.html\n少了动态密钥的获取的请求，不再使用随机生成 key，改为取连接密码的 md5 前 16 位作为密钥 一次请求为判断是否可以建立连接，少了两次 get 获取冰蝎动态密钥的行为，第二次发送 phpinfo 等代码执行。去除了动态密钥协商机制，采用预共享密钥，全程无明文交互，密钥格式为md5(“admin”)[0:16]\n请求头 Pragma: no-cache Cache-Control: no-cache Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 // 或者 Cache-Control: no-cache Pragma: no-cache Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 User-Agent 内置16个UA头，比较老旧\nMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1 Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0 Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50 Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E) Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3) Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB7.0) Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1) Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) Mozilla/5.0 (Windows; U; Windows NT 6.1; ) AppleWebKit/534.12 (KHTML, like Gecko) Maxthon/3.0 Safari/534.12 Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0) Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3 SE 2.X MetaSr 1.0 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1 QQBrowser/6.9.11079.201 Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) QQBrowser/6.9.11079.201 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0) Contetnt-Length 命令执行时，请求包中content-length为5740或5720（可能会根据Java版本而改变）\n4.0 Accept/Content-Length/User-Agent https://www.freebuf.com/articles/network/345803.html\nHTTP头特征 Accept 头通常固定 Accept: application/json, text/javascript, */*; q=0.01 意思是浏览器可接受任何文件，但最倾向application/json 和 text/javascript。 Accept-Encoding: identity Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Content-Length 较大 Content-Length: 8244 作为辅助特征\n默认使用长连接 Connection: Keep-Alive\nContent-Type PHP站点：Content-type: Application/x-www-form-urlencoded\nASP站点：Content-type: Application/octet-stream\n可以把这个字段作为一个弱特征，辅助其他特征来检测\nUser-agent 冰蝎设置了10种User-Agent,每次连接shell时会随机选择一个进行使用。\n响应头字段 Set-Cookie: PHPSESSID=a59734f13f1fe73947e0b3b01ea2aabe; path=/ Pragma: no-cache 流量特征 默认密钥 默认时，所有冰蝎4.0 webshell都有e45e329feb5d925b 一串密钥。该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond\n端口 冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右，每连接一次，每建立一次新的连接，端口就依次增加。\nPHP webshell 中存在固定代码 $post=Decrypt(file_get_contents(\"php://input\")); eval($post); 固定的请求头和响应头\n请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M\n响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd","参考#参考":"知乎 - WebShell流量特征\n语雀 - Webshell相关知识","哥斯拉#哥斯拉":"静态特征 在默认脚本编码的情况下，\nphp、asp为普通的一句话木马 jsp会出现xc、pass字符和Java反射(ClassLoader，getClass().getClassLoader())，base64加解码等特征 动态特征 哥斯拉支持多种加密方式，采用了和冰蝎 2.0 类似的密钥交换方式。它的webshell需要动态生成，可以根据需求选择不同的加密方式。哥斯拉建立连接时会发起三次请求，第一次请求数据超级长，建立 session，第二三次请求确认连接\n请求中的Accept头（弱特征）是\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\n相应头中的Cache-Control头（弱特征）是\nCache-Control: no-store, no-cache, must-revalidate\nCookie的结尾有分号","菜刀#菜刀":"特征 菜刀的木马就是一句话木马\n2014 以前的版本，有的 php/jsp 都为明文传输，较好判断\n2016 后做了加密和混淆，但是有些关键函数还是没有被加密的，比如 /ini_set，z0，eval，assert等。 菜刀的$_POST也可能会被$_GET和$_REQUEST替代。\nPHP 请求包 UA中存在baidu或firefox\n请求体中存在eval，base64等特征，payload为base64编码，存在固定的编码串\n// base64 QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7 // decoded @ini_set(\"display_errors\",\"0\");@set_time_limit(0);if(PHP_VERSION\u003c'5.3.0'){@set_magic_quotes_runtime(0);};echo(\"X@Y\"); 同时可能存在部分未加密函数，比如z0、assert(用于拼接)等\n响应包 明文，格式为X@Y[响应内容]X@Y\nJSP 该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A\u0026z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=参数用来加入攻击载荷。\nASP 其中body流量进行URL解码后 其中特征点有如下三部分\n“Execute”，Execute函数用于执行传递的攻击payload，这是必不可少的，这个等同于php类中eval函数； OnError ResumeNext，这部分是大部分ASP客户端中必有的流量，能保证不管前面出任何错，继续执行以下代码。 Response.Write和Response.End是必有的，是来完善整个操作的。 ","蚁剑#蚁剑":"特征 木马文件官方提供了模板，一句话木马也可以用\nphp中使用assert，eval执行；asp 使用 execute，eval；jsp使用的是Java类加载（ClassLoader）,同时会带有base64编码解码等字符特征\n默认的蚁剑 shell，连接时会请求两次，其请求体只是经过 url 编码，其流量中也存在和蚁剑一样的代码 第一次请求，关闭报错和 magic_quotes，接下来去获取主机的信息 第二次请求，会把主机目录列出来\n请求头中User-Agent值是：antSword/*，也有可能是：Mozilla/5.0 (Windows NT ***) AppleWebKit/*** (KHTML, like Gecko) Chrome/***** Safari/****\nPHP 请求包 PHP类WebShell链接流量，其中body流量进行URL解码后为： 其中流量最中明显的特征为@ini_set(\"display_errors\",\"0\"); @set_time_limit(0)这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现。\n响应包 响应包的结果返回格式为：随机数+响应内容+随机数\n_0x......=，以 0x 开头的参数名。由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以_0x......=这种形式（下划线可替换为其他），以及dirname、get_current_user函数的字眼，后面为加密数据包\nASP body流量进行URL解码后为： 蚁剑针对ASP类的WebShell流量与菜刀的流量很像，其中特征也是相同，如OnError ResumeNext、Response.End、Response.Write，其中execute在蚁剑中被打断混淆了，变成了拼接形式Ex\"\u0026cHr(101)\u0026\"cute，同时该流量中也使用了eval参数，可以被认为明显特征。"},"title":"CTF CheatSheet之WebShell流量分析"},"/matches/ctf-misc-tools/":{"data":{"":"","misc2#MISC^2":"前言 MISC题型多变而且工具繁杂，因此自己花时间整理了一份工具列表，以便日后参考用\n流畅地阅读这篇博客，你可能需要：\nPython2.7.18 + Python3.8 + 任何一个更高版本的Python，使用conda管理 Linux虚拟机，kali即可 流畅访问Google/GitHub等站点的网络 通用工具 PuzzleSolver 专为misc手打造的瑞士军刀(?)，整合了多种脚本（base，字频分析，png/bmp自动修复文件头，图片盲水印等等）的带GUI的工具 仓库：Github - PuzzleSolver\n[随波逐流]CTF编码工具 集成了绝大部分编码的解码/转换工具，有一键解码功能，简单题直接一把梭 官网\n010 Editor 功能强大的十六进制编辑工具，有文件模板功能，便于修改各种缺失文件头文件尾。\nbinwalk 一个分析文件并提取嵌入的文件和代码的工具，可以判断源文件中包含的隐藏文件种类 仓库：Github - binwalk 快速入门：\nbinwalk -e stego.zip #提取stego.zip steghide/stegseek steghide隐写和配套解密工具，配合rockyou.txt食用更佳 快速入门：\nstegseek [stegofile.jpg] [wordlist.txt] #用wordlist暴力破解stegofile stegseek --seed [stegofile.jpg] # 分析此文件是否包含steghide内容，包含多少隐藏内容，是如何加密的 CyberChef 赛博厨子，ctf编码神器，方便易用，可以下载本地离线使用 链接：官网\nCiphey 一个功能强大的ai全自动解密工具，输入密文后自动返回解密文本并指出加密方式（虽然不能百分百解出，但有时候试试会有奇效） 仓库：Github - Ciphet 快速入门：\nciphey -t \"put_encrypted_message_here\" ciphey -f encrypted_message.txt # 加上-q 直接给出结果 # 加上-g 只输出答案 图片隐写 Stegsolve 常用于LSB隐写分析/内容提取、GIF查看单帧\nSilentEye 分析bmp/wav中的隐写\nOurSecret 带密码的jpg隐写工具\nAcropalypse-Multi-Tool 一个基于CVE-2023-28303和CVE-2023-21036漏洞的工具，可用于恢复截图被裁剪掉的部分数据 仓库：Github - Acropalypse Multi Tool\nQR Research 二维码识别/补全软件，支持各种纠错等级和二维码种类\nQrScan 另一个二维码识别软件，特点是能批量识别并输出到csv文件中 仓库：Github - QrScan\nImageMagick/gaps 多功能图像处理工具，多用于拼图，先用ImageMagick把打乱的图像拼接，再使用gaps识别并自动整理 链接（ImageMagick）：Github - ImageMagick \u0026 官网 链接（gaps）：Github - gaps 快速入门：\nmagick.exe montage *.jpg -tile 22x2 -geometry 64x256+0+0 abc.jpg # 将目录里的jpg文件按顺序拼成x轴22块，y轴2块的图 ，每个图块的大小为64X512像素，输出文件为abc.jpg gaps run --image=img.png --size=xxx --save # size填拼图各块的长宽 # 额外参数： –generations # 遗传算法迭代次数，效果不好时适当改变 –population # 个体数量 文件隐写 wbs4.3open 带密码的pdf隐写工具\nAOPR Forensic Edition 文档密码破解工具，支持暴力、字典、掩码等，可利用VBA后门 一个可用的学习版链接：pcbeta\n音频隐写 Audacity 开源的音频编辑软件，可以可视化查看频谱、音轨，便于找出音频中的分析点\nDeepSound 2.0 带密码的wav隐写分析工具\nRX-SSTV 一个sstv识别工具，可将声音信息转为图像\nQSSTV linux上的sstv接收软件，特点是可以直接读取wav音频文件里的信息，免去了外放的困扰 仓库：Github - QSSTV\nmp3stego 正如其名，是一个命令行mp3隐写分析工具 链接：mp3stego\n压缩包分析 ZipCenOp zip伪加密修复 快速入门：\njava -jar ZipCenOp.jar r fake_encrypted.zip ARCHPR 暴力破解工具，支持掩码、字典、明文攻击等手段\nbkcrack zip明文攻击工具，和ARCHPR相比支持更多的参数 条件：1.ZipCrypto加密方式 2.已知其中某个完整的明文文件/已知明文的至少12个字节和偏移（其中又至少8字节要连续）\nhashcat 宇宙最强密码/哈希破解工具，支持多种系统，cpu/gpu/apu计算，支持多种hash算法，可破解rar、office文档、pdf等文件。\n流量分析 WireShark 抓包流量分析软件 快速入门：\nmac地址/ip/端口过滤 eth.addr==20:dc:e6:f3:78:cc //筛选MAC地址是20:dc:e6:f3:78:cc的数据包，包括源或者目的MAC地址\reth.src==20:dc:e6:f3:78:cc //源MAC地址是20:dc:e6:f3:78:cc\reth.dst==20:dc:e6:f3:78:cc //目的MAC地址是20:dc:e6:f3:78:cc\rip.addr==192.168.1.122 //筛选出IP地址是192.168.1.122的数据包，包括源IP地址或者目的IP地址\rip.src== 和ip.dst==同上\rtcp.port==80 //根据TCP端口筛选数据包，包括源端口或者目的端口\rtcp.dstport==80 //根据目的TCP端口筛选\rtcp.srcport==80 //根据源TCP端口筛选\rudp.port==4010 //根据UDP端口筛选数据包，包括源端口或者目的端口\rudp.srcport==4010 //根据源UDP端口筛选\rudp.dstport==4010 //根据目的UDP端口筛选 协议筛选 常见协议：udp，tcp，arp，icmp，smtp，pop，dns，ip，ssl，http，ftp，ssh\nhttp //过滤http流量\rhttp.request.method==GET/POST\rhttp.response\rhttp.response.code \u003e=400（包含错误码）\rhttp.response.phrase == “OK”（过滤响应中的phrase）\rhttp contains \"snapshot\" //过滤http头中含有指定字符\rhttp.server contains “snapshot” //过滤http头中server字段含有指定字符\rhttp.content_type == “text/html” //过滤content_type是text/html的http响应、post包\rhttp.content_encoding == “gzip” //过滤content_encoding是gzip的http包\rhttp.transfer_encoding == “chunked” //根据transfer_encoding过滤\rhttp.content_length == 279\rhttp.content_length_header == “279” //根据content_length的数值过滤\rhttp.server //过滤所有含有http头中含有server字段的数据包 也可参考：知乎 - Wireshark教程\nMISC^2 ntfsstreamseditor NTFS数据流隐写\nveracrypt 磁盘加密软件，可建立虚拟磁盘并利用密码或者密钥文件进行加密，支持各种加密算法\nCheat Engine 功能如其名，做一些游戏题的时候可以用这个走走捷径。 不要和带反作弊的游戏一起开\nbruteHASH 穷举指定格式的数据的HASH值，格式可以为：\n指定明文格式 不限定明文格式随机字符穷举 自定义穷举字符集 CTF 常见 HASH(MD4/MD5/SHA1) 设置 HASH 开头、结尾或包含字符串 ","前言#前言":"","压缩包分析#压缩包分析":"","图片隐写#图片隐写":"","文件隐写#文件隐写":"","流量分析#流量分析":"","通用工具#通用工具":"","音频隐写#音频隐写":""},"title":"CTF MISC常用工具集锦/使用方法简介"},"/matches/hitctf2023-misc/":{"data":{"":"","misc1---leftover-file#MISC1 - leftover file":"","misc2---h1f1#MISC2 - H1F1":"MISC1 - leftover file There is traffic packet captured by engineers on the intranet on the controlled machine. Please analyze the traffic packet and obtain the flag.\n拿到一个捕获文件，有大量Modbus/TCP协议的流量，并且从192.168.181.132 \u003c–\u003e 192.168.181.5的最多。 应用过滤：(modbus) \u0026\u0026(ip.src==192.168.181.132)\u0026\u0026(modbus.func_code==3)，这个的意思是过滤modbus协议，ip来源为192.168.181.132，且功能码为读保持的流量。 追踪流没发现什么线索，最后发现每条流量的最后部分，都会有规律地刷新： 提取这一部分的字符串： GGQ?O@+())pA#VSebM`[J]XGZUDIDUZ] 用工具解密得到flag MISC2 - H1F1 Some audiophiles claim they can hear the difference between 320K mp3 and lossless audio. 无损听不出来，但是192k和320k的mp3还是很容易分辨的\n给了一首歌的flac和mp3版本，根据描述应该是让我们从两个音频的差别来找线索 首先用audition将其中一首反相，再和另外一首进行混音，预览页面可以看到频谱有异常部分，并且左右耳能听到规律性的“嘟”声。 猜测是二进制序列，把上面的部分（左声道）视为0，下面视为1，提取出二进制序列： 01001000010010010101010001000011010101000100011000110010001100000011001000110011011110110111100100110000011101010101111101001000011000010111011000110011010111110110011100110000011011000100010000110011011011100101111100110011011000010111001001010011010111110011001101100011001100000011001100110001001101000011000001100110011000010110001001100001001110010110001001100110001110000110010001111101 解码得到flag "},"title":"[HITCTF2023] MISC1\u00262 WP"},"/matches/iscc2023-beijing-fin-misc/":{"data":{"":"","后话#后话":"考点 流量分析，TLS，二维码修复\n解题步骤 首先速览一遍帮帮小明.pcapng，发现里面的协议有IMAP和TLS，这部分可能有线索 打开统计-\u003e会话，TCP栏有两个终点为25端口的地址，追踪流量，是两次对话 发现一个压缩包 保存，发现有密码，里面是一个加密后的文件mosaic.bmp，用zipcenop排除了伪加密的可能性，所以密码应该在另一个tcp流中 发现一段明文，用的gb2312编码，用vscode打开： 害，怎么密码忘了呢，只能往后面慢慢找了 这里附件还给了tls-log.txt，猜测需要解密tls密文，在编辑——\u003e首选项——\u003eProtocols——\u003eTLS——\u003e(Pre)-Master-Secret log filename这里加入即可 最后在某个TLS流找到了密码cAn_yOU_hElp_mE 解压压缩包，得到图片mosaic.bmp 还好队友见过原题，直接把脚本放了上来，参数甚至一点没变就可以用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 import math import numpy as np from PIL import Image from numpy.lib import ndindex X, Y = 103, 137 N = 20 BOX_SIZE = 23 PIXEL_SIZE = 11 def set_pix(array, x, y, val): '''将图片数组 array 中第 (x, y) 个二维码格设为 val ''' x1 = x * PIXEL_SIZE x2 = (x+1) * PIXEL_SIZE y1 = y * PIXEL_SIZE y2 = (y+1) * PIXEL_SIZE array[x1:x2, y1:y2] = val # check box[i, j] def check(ar, i, j): '''判断图片数组 ar 生成的马赛克的第 (i, j) 个块是否要求的相符 即比较数组 ar 对应位置的平均值和马赛克数组的对应格 ''' x1 = X + i*BOX_SIZE x2 = X + (i+1)*BOX_SIZE y1 = Y + j*BOX_SIZE y2 = Y + (j+1)*BOX_SIZE # print('box:\\n', ar[x1:x2, y1:y2]) mean = ar[x1:x2, y1:y2].mean() return math.floor(mean) == mosaic[i, j] def set_pixels(ar, uncertains, t): for k, pos in enumerate(uncertains): color = ((t \u003e\u003e k) \u0026 1) * 255 set_pix(ar, pos[0], pos[1], color) def solve(): error = False # for every box in pixelated area. for (i, j) in np.ndindex(mosaic.shape): # 考虑马赛克的每个格子 (i, j)，在 ar 中起始坐标是 (x, y) x = X + i*BOX_SIZE y = Y + j*BOX_SIZE # 只有从 (px, py) 开始的 3x3 个二维码格子会影响这个马赛克格子 px = x // PIXEL_SIZE py = y // PIXEL_SIZE # 3x3 个格子中还不确定的位置 uncertains = [] for tx, ty in np.ndindex(3, 3): if not flags[px+tx, py+ty]: uncertains.append((px+tx, py+ty)) if len(uncertains) == 0: continue possibles = [] print(f'Try mosaic{(i, j)}, from pixel{(x, y)}, uncertains: {uncertains}') for t in range(2**len(uncertains)): '''遍历2^k种可能性''' # print('Try: {0:0{1}b}'.format(t, len(uncertains))) set_pixels(ar, uncertains, t) # 将 ar 对应位置按 t 的每一位设置为对应颜色 if check(ar, i, j): # 判断马赛克颜色是否正确，正确则加入可能性列表 possibles.append(t) if len(possibles) == 1: # 只有一种可能性，那么是正确答案 set_pixels(ar, uncertains, possibles[0]) for x, y in uncertains: flags[x, y] = True elif len(possibles) \u003e 1: # 多个可能就随便设一个，但是不标记为已经确定 set_pixels(ar, uncertains, possibles[0]) # 也可以用下面的方法，将所有可能性中颜色都相同的格子找出来，设置为确定的 # 这样可以大大增加能解出的格子数（从 81% 提升到 88%） # print(possibles) # a = np.bitwise_and.reduce(np.asarray(possibles)) # b = np.bitwise_or.reduce(np.asarray(possibles)) # c = np.bitwise_xor(a, b) # print(f'{c:0{len(uncertains)}b}') # for k, pos in enumerate(uncertains): # color = ((possibles[0] \u003e\u003e k) \u0026 1) * 255 # set_pix(ar, pos[0], pos[1], color) # if (c \u003e\u003e k) \u0026 1 == 0: # flags[pos[0], pos[1]] = True elif len(possibles) == 0 and len(uncertains) != 0: # 出现不明原因的错误 print(f'Error: [{i}, {j}]') error = True break if error: break print(f'Solved: [{i}, {j}]') return flags.sum() # 返回目前确定的格子数 im = Image.open('pixelated_qrcode.bmp') ar = np.asarray(im, dtype='uint8') # 在该数组上逐步恢复和试算二维码 mosaic = ar[X::BOX_SIZE, Y::BOX_SIZE][:N, :N].copy() # 马赛克每格的数据 solved = ar[::PIXEL_SIZE, ::PIXEL_SIZE] # 用于存放答案，开始取二维码每格左上角值 # 注意 solved 是个引用，所以修改 ar 会跟着变 flags = (solved == 0) | (solved == 255) # 如果某格是 0 或 255，已经能确定颜色 rd_corner = ar[PIXEL_SIZE-1::PIXEL_SIZE, PIXEL_SIZE-1::PIXEL_SIZE] # 二维码每格右下角 rd_flags = (rd_corner == 0) | (rd_corner == 255) # 按右下角能确定颜色的二维码格 for i, j in np.ndindex(flags.shape): # 按左上角和右下角边缘，将能够确定的格补全 if flags[i, j]: set_pix(ar, i, j, solved[i, j]) if rd_flags[i, j]: set_pix(ar, i, j, rd_corner[i, j]) flags = (solved == 0) | (solved == 255) # 更新已确定的位置 while True: # 如果有新的格子被推算出来，那么继续算，否则已经没得算了 num_ok = flags.sum() if solve() == num_ok: break solved_im = Image.fromarray(ar) solved_im.save('solved.bmp') print('CertainRate:', flags.sum() / flags.size) 解密后读取二维码即可\n后话 这次iscc线下真的有点抽象，关卡题打到12点还只有我们队解出来了这一题，其他队伍都是爆零，后来主办方延时到18点，结果还是没人解出来…awd也很难搞，开始3h的pwn和web私地都只有寥寥几队打进来，主办方看不下去了就开放了pwn私地，可惜当时也不会打其他队伍，就简单布防了一下，不过虽然没拿分但也没被打，还是保住了排名\n总的来说是难度偏大的一次线下。","考点#考点":"","解题步骤#解题步骤":""},"title":"[ISCC2023线下] MISC1 WP"},"/matches/qiangwang2024-misc/":{"data":{"":"","考点#考点":"","解题步骤#解题步骤":"考点 流量分析，哈希爆破，Samba协议，RDP键盘流量\n解题步骤 首先翻找一下，发现有大量的SMB和RDP协议流量。 先从开头的SMB2建立会话入手，可知进行过一次成功的连接，并有加密流量传输。从包121、122中可提取出相关信息进行爆破：\nDomain name: . User name: tom NTLM Server Challenge: c1dec53240124487 NTProofStr: ca32f9b5b48c04ccfa96f35213d63d75 Session Key: 5643a37f253b00b2f52df1afd48c1514 modifiedntlmv2response(去除 NTProofStr 后的一整个 NTLM Response 流): 010100000000000040d0731fb92adb01221434d6e24970170000000002001e004400450053004b0054004f0050002d004a0030004500450039004d00520001001e004400450053004b0054004f0050002d004a0030004500450039004d00520004001e004400450053004b0054004f0050002d004a0030004500450039004d00520003001e004400450053004b0054004f0050002d004a0030004500450039004d0052000700080040d0731fb92adb0106000400020000000800300030000000000000000100000000200000bd69d88e01f6425e6c1d7f796d55f11bd4bdcb27c845c6ebfac35b8a3acc42c20a001000000000000000000000000000000000000900260063006900660073002f003100370032002e00310036002e003100300035002e003100320039000000000000000000 # 组合方式：username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response tom::.:c1dec53240124487:ca32f9b5b48c04ccfa96f35213d63d75:010100000000000040d0731fb92adb01221434d6e24970170000000002001e004400450053004b0054004f0050002d004a0030004500450039004d00520001001e004400450053004b0054004f0050002d004a0030004500450039004d00520004001e004400450053004b0054004f0050002d004a0030004500450039004d00520003001e004400450053004b0054004f0050002d004a0030004500450039004d0052000700080040d0731fb92adb0106000400020000000800300030000000000000000100000000200000bd69d88e01f6425e6c1d7f796d55f11bd4bdcb27c845c6ebfac35b8a3acc42c20a001000000000000000000000000000000000000900260063006900660073002f003100370032002e00310036002e003100300035002e003100320039000000000000000000 使用组合后的hash在hashcat中爆破。这里尝试了很多自定义掩码都没能解出，最后用133MB的rockyou成功爆破出来： 最后得出SMB账号密码：tom:babygirl233，随后使用用户名、域、密码和其他内容计算Session Key。 SMB Decryption - TryHackMe\nfrom Crypto.Cipher import ARC4 from Crypto.Hash import MD4, MD5, HMAC password = 'Blockbuster1' passwordHash = MD4.new(password.encode('utf-16-le')).hexdigest() username = 'mrealman' domain = 'workgroup' ntProofStr = '16e816dead16d4ca7d5d6dee4a015c14' serverChallenge = '2a9c5234abca01e7' sessionKey = 'fde53b54cb676b9bbf0fb1fbef384698' responseKey = HMAC.new(bytes.fromhex(passwordHash), (username.upper()+domain.upper()).encode('utf-16-le'), MD5).digest() keyExchangeKey = HMAC.new(responseKey, bytes.fromhex(ntProofStr), MD5).digest() decryptedSessionKey = ARC4.new(keyExchangeKey).decrypt(bytes.fromhex(sessionKey)) print('Decrypted SMB Session Key is: {}'.format(decryptedSessionKey.hex())) 得到Session Key为a3abe4d64394909a641062342ffe291b，和Session ID0900000000100000组合起来，放入Wireshark中的SMB2解密。（这里的Session ID要转换为小端序） Wireshark提取SMB文件，得到flag压缩包和某个机器的某证书 那么下一步应该就是解密RDP流量了，Wireshark导入证书即可，不过这里只给了pfx证书，需要自己转换为pem文件，密码是mimikatz（试出来的） 春雪 - 如何使用Wireshark解密Windows远程桌面（RDP）协议 公钥私钥都需要 导入证书后即可解密出RDP流量，其中包含鼠标的移动轨迹和键盘输入 其中鼠标轨迹无意义： 什么也没有 考虑输入字符(ScanCode部分) Scan Codes Demystified 这里我直接把RDP流全部转存为文本然后正则提取出了对应的键盘输入流，并和Scan Code的Set 1进行匹配：\nimport re input_file_path = 'rdp.txt' # 这里为导出RDP分组（解密后）的txt output_file_path = 'keycodes_output.txt' keycode_to_char = { 0x01: 'Esc', 0x02: '1', 0x03: '2', 0x04: '3', 0x05: '4', 0x06: '5', 0x07: '6', 0x08: '7', 0x09: '8', 0x0A: '9', 0x0B: '0', 0x0C: '-', 0x0D: '=', 0x0E: 'BackSpace', 0x0F: 'Tab', 0x10: 'Q', 0x11: 'W', 0x12: 'E', 0x13: 'R', 0x14: 'T', 0x15: 'Y', 0x16: 'U', 0x17: 'I', 0x18: 'O', 0x19: 'P', 0x1A: '[', 0x1B: ']', 0x1C: 'Enter', 0x1D: 'LCtrl', 0x1E: 'A', 0x1F: 'S', 0x20: 'D', 0x21: 'F', 0x22: 'G', 0x23: 'H', 0x24: 'J', 0x25: 'K', 0x26: 'L', 0x27: ';', 0x28: \"'\", 0x29: '`', 0x2A: 'LShift', 0x2B: '\\\\', 0x2C: 'Z', 0x2D: 'X', 0x2E: 'C', 0x2F: 'V', 0x30: 'B', 0x31: 'N', 0x32: 'M', 0x33: ',', 0x34: '.', 0x35: '/', 0x36: 'RShift', 0x37: '*', 0x38: 'LAlt', 0x39: 'Space', 0x3A: 'CapsLock', 0x3B: 'F1', 0x3C: 'F2', 0x3D: 'F3', 0x3E: 'F4', 0x3F: 'F5', 0x40: 'F6', 0x41: 'F7', 0x42: 'F8', 0x43: 'F9', 0x44: 'F10', 0x45: 'NumLock', 0x46: 'ScrollLock', 0x47: '7', 0x48: '8', 0x49: '9', 0x4A: '-', 0x4B: '4', 0x4C: '5', 0x4D: '6', 0x4E: '+', 0x4F: '1', 0x50: '2', 0x51: '3', 0x52: '0', 0x53: '.', 0x54: 'SysRq', 0x56: 'INT1', 0x57: 'F11', 0x58: 'F12', 0x70: 'Katakana', 0x73: 'INT3', 0x77: 'Furigana', 0x79: 'Kanji', 0x7B: 'Hiragana', 0x7D: 'INT4', 0xE01C: 'EnterKP', 0xE01D: 'RCtrl', 0xE038: 'RAlt', 0xE047: 'HomeCP', 0xE048: 'UpCP', 0xE049: 'PgUpCP', 0xE04B: 'LeftCP', 0xE04D: 'RightCP', 0xE050: 'DownCP', 0xE051: 'PgDnCP', 0xE052: 'InsCP', 0xE053: 'DelCP', 0xE05B: 'LWin', 0xE05C: 'RWin', 0xE05D: 'WinMenu', 0xE05E: 'Power', 0xE05F: 'Sleep', 0xE063: 'Wake', 0xE020: 'Mute', 0xE030: 'VolumeUp', 0xE02E: 'VolumeDown', 0xE017: 'Cut', 0xE018: 'Copy', 0xE00A: 'Paste', 0xE03B: 'Help', 0xE008: 'Undo', 0xE007: 'Redo', 0xE022: 'Play', 0xE024: 'Stop', 0xE010: 'SkipBack', 0xE019: 'SkipFwd', 0xE02C: 'Eject', 0xE01E: 'Mail', 0xE032: 'Web', 0xE03C: 'Music', 0xE064: 'Pictures', 0xE06D: 'Video', 0x5B: 'F13', 0x5C: 'F14', 0x5D: 'F15', 0x63: 'F16', 0x64: 'F17', 0x65: 'F18', 0x66: 'F19', 0x67: 'F20', 0x68: 'F21', 0x69: 'F22', 0x6A: 'F23', 0x6B: 'F24', 0x75: 'Help', 0x71: 'AttnSysRq', 0x76: 'Clear', 0x77: 'Again', 0x72: 'CrSelProperties', 0x78: 'Undo', 0x74: 'ExSelSetUp', 0x6D: 'ErEOFRecrd', 0x80: 'Copy', 0x83: 'PrintIdent', 0x6F: 'CopyTest', 0x81: 'Paste', 0x82: 'Find', 0x79: 'Cut', 0xE04C: 'Rule' } extracted_chars = [] try: with open(input_file_path, 'r', encoding='utf-8') as file: for line in file: match = re.search(r'KeyCode:\\s*0x([0-9A-Fa-f]{2})', line) if match: keycode = int(match.group(1).upper(), 16) char_output = keycode_to_char.get(keycode, '?') extracted_chars.append(char_output) extracted_chars.append(\" \") with open(output_file_path, 'w', encoding='utf-8') as output_file: output_file.write(''.join(extracted_chars)) print(\"提取完成，结果已保存至\", output_file_path) except Exception as e: print(\"发生错误:\", e) 得到\nTab LShift RShift LCtrl LCtrl Tab LAlt Tab LAlt Tab Tab LShift RShift LCtrl LCtrl Tab LAlt Tab LAlt Tab Tab F13 F14 LShift RShift LCtrl LCtrl Tab LAlt Tab LAlt Tab Enter Enter T T H H E E LShift LShift Space Space 7 7 Z Z Space Space P P A A S S S S W W O O R R D D Space Space I I S S Space Space F F ' ' LShift [ [ LShift W W I I N N D D O O W W S S LShift - - LShift P P A A S S S S W W O O R R D D LShift ] ] LShift 9 9 3 3 4 4 7 7 0 0 1 1 3 3 1 1 8 8 2 2 ' ' LCtrl S S LCtrl Tab LShift RShift LCtrl LCtrl Tab LAlt Tab LAlt Tab # the 7z password is f'{windows_password}9347013182' windows password即SMB协议的用户密码babygirl233，合并得到解压密码为babygirl2339347013182，解压flag.7z即可得到flag"},"title":"[强网2024初赛] MISC-谍影重重5.0 WriteUp"},"/matches/xihu2024-initial-misc/":{"data":{"":"","内存取证#内存取证":"","爆破#爆破":" easy raw! many passwords!\n内存取证 首先用volatility+mimikatz可以爆出windows账户密码das123admin321 vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 mimikatz 剪贴板中，有另一个密码DasrIa456sAdmIn987，用来解压mysecretfile.rar vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 clipboard mysecretfile用了veracrypt加密，需要另一个密码，所以继续找线索 搜索相关文件，可以发现pass.zip，并用dumpfiles提取 vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 filescan | grep -E ‘png|jpg|gif|zip|rar|7z|pdf|txt|doc’ vol.py --plugins=./plugins -f ./rawraw.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000003df8b650 -D .\\\n爆破 图片末尾提取出加密压缩包，ARCHPR爆破得密码20240210，解压得到pass.txt，挂载之后有一个隐藏文件.xlsx，也要密码，试出来就是之前得到的账户密码das123admin321 打开发现第10行被隐藏了，flag就在其中"},"title":"[西湖论剑2024初赛] MISC3-easy_rawraw WriteUp"},"/misc/":{"data":{"":"","#":"最近更新 Lakka模拟器部署教程 "},"title":"Misc"},"/misc/raspi-simulator-tutorial/":{"data":{"":"","做一些微小的工作#做一些微小的工作":" 🎮 Lakka原生支持有线无线手柄，以下内容均可使用一个手柄完成 进入系统界面后，使用手柄进入Wi-Fi，连接网络（需要和你的电脑在同一内网下），或者直接插网线，然后进入设置-\u003e服务，打开SSH和SAMBA协议；接下来在菜单-\u003e系统信息-\u003e网络信息界面查看本机ip地址192.168.x.x，记下来。\n适当超频以获得更好的性能 对于树莓派4b，将sd卡插入电脑后，在【？？？】盘根目录下的config.txt中增加以下参数即可：\n# overclock over_voltage=6 # 增加电压 arm_freq=2000 # CPU 频率，单位是 MHz，最高 2147 gpu_freq=750 # GPU 频率，单位是 MHz force_turbo=0 # 为确保安全，以动态频率运行 对于之前的机型，超频参数可以参考： 树莓派如何超频\n系统空间扩容 烧录后系统的可用空间会比实际的存储介质容量小，所以需要扩容。 拿到地址后用SSH连接，账号密码均为root，然后依次执行下列命令：\nsystemctl stop retroarch mv .config .config.bak mv .cache .cache.bak touch /storage/.please_resize_me sync reboot 正常情况下，系统会多次重启。喝杯水回来，重新打开SSH和SAMBA协议，再次用SSH连接，依次执行下列命令：\nsystemctl stop retroarch rm -fr .cache .config .kodi mv .config.bak .config mv .cache.bak .cache sync reboot 设置中文 Lakka自带中文翻译，但是自带的字体中文显示不全，所以要替换字体。可以直接使用系统自带的微软雅黑，文件后缀为.ttf 使用WinSCP，选择SCP协议，用相同的地址、账号密码登录，然后进入/tmp/assets/xmb/monochrome下，将原本的font.ttf重命名为font.ttf.bak，然后将准备的字体文件重命名为font.ttf，复制到这个目录下。 随后，进入设置，将语言改为中文即可。\n其他 Lakka可以折腾的地方很多，比如：\n系统音视频设置 控制器键位设置 第三方成就 各种模拟器的内部设置 远程联机 这一部分就留给读者自行探索了。\n⚠️ 建议先备份一份配置文件/storage/.config/retroarch/retroarch.cfg，不小心折腾炸了可以进SSH手动恢复 ","准备工作#准备工作":"需要准备的硬件 一台电脑，一个树莓派（最好pi3及以上），或任何能安装Linux的机器 sd卡（32g及以上），或者一块硬盘 输入输出设备（显示器、键盘或手柄） 流畅、能上外网的网络连接 需要准备的软件 Raspberry Pi Imager，用于烧录镜像 SSH工具，推荐Termius或者MobaXterm用于建立连接 WinSCP，用于网络传送文件到树莓派 参考网站 Lakka官网\n树莓派系统烧录工具\n个人常用的复古游戏资源站\nWinSCP","前言#前言":"最近有点心痒，总想着要折腾点东西，于是把吃灰两年多的树莓派4b翻了出来。正经 Linux 想必是带不动的，手头上又正好有几个psp游戏，于是便想着装个模拟器，在 RetroPie 和 Lakka 之间选了界面更美观的 Lakka。","后记#后记":"左边是LGBT，右边是玩家策划对立，2024年的游戏圈子属实不太安定。如果感到厌倦了，不妨把老游戏捡起来，那可是一座宝藏。","游戏启动#游戏启动！":"用WinSCP将游戏ROM放入/storage/roms/下（也可以用文件夹分类不同游戏机的游戏），然后在系统中选择导入-\u003e扫描文件夹页面，在这个目录下选择\u003c扫描此文件夹\u003e，等待片刻即可自动导入游戏。\n实际测试中，树莓派4b可以完美高分辨率模拟运行除PSP以外的各种主机，PSP也可以在低于1080p的分辨率下流畅运行。不过运行时发热量略大，需要使用铝散热片或者散热壳加上风扇，否则可能降频。","烧录系统#烧录系统":"在 Lakka 官网下载对应系统的镜像，并用 Raspberry Pi Imager 烧录，可以不用设置任何东西。烧录完成会有提示。（在非树莓派机器上烧录，请查阅其他资料）\n没什么问题的话，烧录完直接连接到树莓派上即可。插电开机，第一次启动会需要一些时间，稍等片刻。\nℹ️ 如果提示文件系统错误之类，属正常现象，等待120s后自动修复即可进入系统 "},"title":"在树莓派上运行怀旧游戏——Lakka模拟器部署教程"},"/misc/why-my-blog-misfunctions/":{"data":{"":"","解决方案#解决方案":"解决方案是将/blogs文件夹重命名为其他名字，比如/myblog，然后执行hugo --gc重新生成。","起因#起因":"之前一直用的是Hugo 0.126.1版本，并且我的一个博客子页面放在文件夹/blogs下。最近换了电脑，顺带升级到最新的Hugo版本，编译的时候发现生成的网页在/blogs下会出现显示错位的问题。排查一番发现，新版本的Hugo会默认将生成的所有网页创建一个副本放在/blogs下，和我的子页面冲突了。"},"title":"高版本Hugo的一个注意事项"},"/myblog/":{"data":{"":"","#":"最近更新 关于Promise的一些探究 React Fiber流程简介 从rAF()探究浏览器帧渲染流程 "},"title":"Blog List"},"/myblog/hextra-setup-tutorial/":{"data":{"":"","一些容易踩的坑#一些容易踩的坑":"","准备工作#准备工作":"","参考资料#参考资料":" 以Hextra主题为例的Hugo博客搭建指南\n准备工作 安装好Go和Hugo(extended version) 配置好Git 拥有一个域名(可选) 速通 ℹ️ 施工中 建立两个仓库，分别存放源代码和生成的静态文件 Hugo初始化博客，目标文件夹与源代码仓库同名 拉取Hextra主题到./themes/hextra，拉取静态文件仓库到./public（使用git submodule） 配置hugo.yaml，参考exampleSite 写一点东西 生成静态文件，检查，推送到远程仓库 配置Github Pages到静态文件仓库中 (可选) CLoudflare 绑定域名解析 一些容易踩的坑 文件完整性校验不通过导致博客功能失效1 如图 为确保脚本或者样式表不被恶意篡改，网页会使用integrity来校验文件完整性，如果计算的SHA-256值和指定的不匹配，则浏览器拒绝加载此资源。 而在hugo生成静态资源后，如果尝试将其上传到github，有可能文件中的换行符会被git自动转换，导致本地文件和云端文件校验值不同。 解决方法是关闭git自带的CRLF\u003c–\u003eLF转换：\ngit config --global core.autocrlf false 或者指定某个仓库不转换\nCloudflare Pages自动构建过程出错 暂时未找到解决方法，替代品是直接让它部署生成后的静态页面\n参考资料 Hextra Hugo 头部自定义参数 Issue ↩︎","速通#速通":""},"title":"Hextra主题博客搭建指南"},"/myblog/how-raf-and-frame-works/":{"data":{"":"","requestanimationframe#requestAnimationFrame()":"","佚事#佚事":"requestAnimationFrame() MDN对rAF()的解释：\nwindow.requestAnimationFrame() 方法会告诉浏览器你希望执行一个动画。它要求浏览器在下一次重绘之前，调用用户提供的回调函数。对回调函数的调用频率通常与显示器的刷新率相匹配。最常见的刷新率是 60hz。\n使用window.cancelAnimationFrame(rafId)作用于rAF()的返回值，取消回调函数执行操作。\n若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 requestAnimationFrame()。requestAnimationFrame() 是一次性的。\nrequestAnimationFrame() 是一个宏任务。\n使用示例：\nlet requestId; function init(val) { console.log(\"回调发生在时间:\", val); // rAF执行的回调函数只有一个参数val，是上一帧渲染的结束时间戳 requestId = requestAnimationFrame(init); } requestAnimationFrame(init); function stop() { cancelAnimationFrame(requestId); } 特点以及机制 为什么使用rAF()而不是setTimeout()？ 计时精确，帧生成时间稳定 帧生成时间指的是每个完整帧从开始到结束渲染的时间。一般情况下，帧生成时间要小于当前刷新率下每帧持续显示的时间，这样才能确保画面显示稳定。否则可能会导致画面操作卡顿不跟手等问题。\n恼人的卡顿 requestAnimationFrame() 的间隔时间由浏览器决定。浏览器内核监听显示器的VSync（垂直同步）信号，并自动同步频率，使requestAnimationFrame() 能够以精确的16.67ms触发回调（60帧的情况下）。\n而setTimeout() 、setInterval()等方法会受到JS事件队列执行的影响，每次触发回调的时长会发生抖动。\n自带FPS Meter监控帧时长 浏览器内部会使用requestAnimationFrame() +高精度计时器记录帧生成时间、FPS、任务执行时间等数据，如果过长或者触发阈值，浏览器会延迟显示（导致FPS下降），或者主动跳过当前帧的渲染（更新状态但是不光栅化）。\n页面处于后台或者元素不可见时暂停 为了提高性能和电池寿命，大多数浏览器都会暂停在后台选项卡或者隐藏的 \u003ciframe\u003e 中运行的 requestAnimationFrame() 。\n浏览器一帧的生命周期 简单来说，一个帧的完整生命周期如下：\n简要步骤 在主线程中处理输入、JS事件（包括同步和异步任务） 由VSync信号驱动，检测是否需要更新页面，并触发一些系统事件 使用requestAnimationFrame() 执行回调，这是动画系统最后的同步操作DOM的时机 计算样式，处理Layout（回流）等内容 计算/标记重绘部分，交给GPU或者渲染线程进行光栅化 rAF() 在这里负责接受VSync同步信号，执行动画回调。\n而在Chromium文档中，一帧从开始到展现是如下的步骤：\n分进程时序图 整个过程首先由四个进程组成：\nMain Thread(blink): 主渲染进程，执行JS、布局和样式更新计算，把渲染树交给Layer Compositor Layer Compositor (cc): 渲染进程，负责合成层调度、调用光栅化线程、提交frame给Display Compositor Display Compositor: 副GPU进程，汇总Layer Compositor的frame，发起GPU绘制 GPU Main: 真正执行GPU绘制、提出SwapBuffer请求，将buffer内容贴到屏幕 按顺序，分别会进行如下操作：\nDisplay Compositor发起帧准备，让Layer Compositor做层更新工作。 Layer Compositor告知Main Thread进行计算样式/布局/重绘渲染树。 Main Thread返回Render Tree给Layer Compositor。 Layer Compositor等待光栅化完成（这一步可能在其他的线程甚至进程中），然后激活形成新的Layer Tree，等待直到GPU规定的提交deadline，再提交给Display Compositor。（这里，如果之前的工作耗时过长，处理管线可能会丢弃这一更新，导致丢帧） Display Compositor收集所有的CompositorFrame（和DidNotProduceFrame，如果丢帧），整合成单一的CompositorFrame。 Display Compositor进行绘制操作（生成绘制命令），提交给GPU Main，请求交换Buffer。 GPU Main等到上一个frame处理完成后再进行（硬件级）GPU绘制，使用Display Compositor的绘制命令进行绘制，绘制使用的是Chromium的Skia图形库记录的Deferred Display List。 如果上一个frame还没有显示完，或者队列太满则会被阻塞，否则进行SwapBuffer请求（把已经画好的back buffer和当前显示的front buffer进行交换，双缓冲） 交换完buffer之后，等待对齐下一个VSync再显示到显示器中。 用流程图简化表示如下：\nVSync ↓ GPU 进程（Display Compositor） → 渲染进程（Compositor Thread） → 渲染进程（Main Thread）做 JS/Layout ↓ 渲染进程 LayerCompositor 栅格化 + 提交 frame ↓ GPU 进程（汇总、绘制、Swap） ↓ 显示在屏幕上 参考资料\n拓展 requestIdleCallback() 是浏览器提供的一种低优先级任务调度API，允许开发者在浏览器空闲时期执行其他任务。这里的浏览器空闲时期指的是：\n前一帧渲染完成到后一帧开始渲染的间隔 用户处于idle状态，并且没有任何动画执行的时期 特点：\n不能保证任务在何时执行。如果渲染事件紧密，可能腾不出执行rIC() 的时间。 空闲回调时，任务执行的上限时间是50ms ，目的是*”ensure responsiveness to new user input within the threshold of human perception”1*，防止用户突然操作感受到页面阻塞。 兼容性不理想（Safari全版本不支持）；触发频率较低；早期SWR使用rIC() 会和浏览器插件冲突。 佚事 其一 查阅资料时，发现早期浏览器对requestAnimationFrame() 的执行顺序不同，Chrome v71、Firefox等符合标准的浏览器会在style/layout/paint之前、JS事件循环之后触发回调，而IE、Edge、Safari则是在style/layout/paint之后触发。\n而HTML标准里，requestAnimationFrame() 被规定在更新渲染中（即render下一帧之前）\nHTML 标准 因此使用以下的代码，在标准下应该从左开始移动：\nconst test = document.querySelector(\".test\"); const testButton = document.getElementById(\"testButton\"); const resetButton = document.getElementById(\"resetButton\"); test.style.transform = \"translate(0, 0)\"; test.style.transition = \"none\"; testButton.addEventListener(\"click\", () =\u003e { // 重置状态 test.style.transition = \"none\"; // 设置初始变换 test.style.transform = \"translate(400px, 0)\"; requestAnimationFrame(() =\u003e { test.style.transition = \"transform 3s linear\"; test.style.transform = \"translate(200px, 0)\"; }); }); resetButton.addEventListener(\"click\", () =\u003e { test.style.transition = \"none\"; test.style.transform = \"translate(0, 0)\"; }); 但是，在笔者的浏览器（较新的Safari+Chrome）上，均会从右向左移动，似乎把回调推迟到了下一帧，这就很奇怪了，可能是浏览器的优化策略所致。\n标准下应该从左向右移动 参考资料\n其二 React 16.2.0弃用了requestAnimationFrame() ，采用message event loop。不仅是因为上文中的回调时机问题，也是因为MessageChannel 较为稳定，不会像setTimeout() 一样有4ms的最小延迟，也不会像requestAnimationFrame()一样触发事件受浏览器更新机制和VSync的影响。它既能及时让出主线程，又能够确保消息的稳定传递。\nGitHub PR\n参考资料\nHTML Standard 8.1.7.3 - 5.2.1 Note ↩︎","拓展#拓展":"","特点以及机制#特点以及机制":""},"title":"从rAF()探究浏览器帧渲染流程"},"/myblog/js-promise-deepdive/":{"data":{"":"","promise的实现#Promise的实现":"大部分博客中，Promise的实现都只会列出这样的用法：\nconst promise = new Promise((resolve, reject) =\u003e { // 异步操作 if (success) { resolve(value); } else { reject(error); } }).then(result =\u003e { // 处理结果 }).catch(error =\u003e { // 处理错误 }); 按直觉，我们会认为新建的这个Promise对象会按顺序“自动地”执行里面的异步操作，并在某个时刻完成。但实际上，new Promise(...)并不代表“我要开始一个异步任务，实现完之后调用resolve()或者reject()，接下来调用then()”，而是“我想要一个Promise对象，但是什么时候放东西进去，什么时候让它返回数据，由我自己决定”。也就是说，Promise对象的创建和异步操作的执行是两个独立的过程。在这个例子中：\nreturn new Promise((resolve, reject) =\u003e { this.pendingResolvers.get(key).push([resolve, reject]); }); 这段代码只是创建并返回了一个Promise对象，然后把它的resolve()和reject()方法放进了一个请求队列的数组里，没有执行任何异步操作，也没有兑现任何结果。这个Promise对象永远处于pending状态，直到其他地方（比如用一个_flush()方法对队列中的每个[resolve, reject]进行处理），才会改变自己的状态。此时Promise的then()、catch()都处于挂起状态，直到监听到Promise对象被兑现才会执行。\n这种模式被称为deferred模式，或者“延迟对象”，先创建一个deferred，把它传出去，等什么时候操作完成了（未必是异步，并且异步操作甚至可以不在该deferred对象里面），再调用它的resolve()或者reject()来兑现承诺。这是个很有意思的点，代表很多时候Promise可以被当做一个“容器”，先传递给需要的人，等到有了东西才放进去让人使用。理解这一点之后，再回头看then()、catch()就会发现，那些都是在监听“承诺何时被兑现”，而不是在参与“异步过程的发起”。","代码分析#代码分析":"上面的代码实现的是一个BatchRequestManager类，它的作用是批量请求数据，并且支持缓存、去重、取消等功能。我们探讨的关键代码如下：\nget(key) { ... const promise = new Promise((resolve, reject) =\u003e { this.pendingResolvers.get(key).push([resolve, reject]); }); if (!this.timer) this.timer = setTimeout(() =\u003e this._flush(), this.delay); // 启动定时器 return promise; } async _flush() { const keys = Array.from(this.keysToFetch); this.keysToFetch.clear(); this.timer = null; let results; try { results = await this.batchRequestFn(keys); } catch (err) { ... return; } for (const key of keys) { if (key in results) { const value = results[key]; this.cache.set(key, value); const resolvers = this.pendingResolvers.get(key) || []; for (const [resolve] of resolvers) { resolve(value); } } else { const resolvers = this.pendingResolvers.get(key) || []; for (const [_, reject] of resolvers) { reject(new Error(`no data for key: ${key}`)); } } this.pendingResolvers.delete(key); } } 经过之前的探讨后，我们就可以理清楚这个代码的逻辑了：\nget(key)中会创建一个新的Promise对象，并把它的resolve()和reject()方法放进一个请求队列中。此时这个Promise对象处于pending状态，并且什么也没干。 接下来延迟50ms后调用_flush()方法。_flush()方法会请求队列中取出所有的key，并调用batchRequestFn(keys)方法批量请求数据。 如果请求成功，遍历所有的key，把它们的结果放入缓存中，并调用每个key对应的Promise对象的resolve()方法，改变它们的状态为fulfilled。否则变为rejected。 当状态变为fulfilled或者rejected时，所有监听这个Promise对象的then()、catch()方法会被调用。 ","前言#前言":"对于Promise，我们都知道它是一个代表异步操作的对象。它有三种状态（pending、fulfilled、rejected），并且可以绑定回调函数来处理操作结果。但是，我最近写了一点异步请求的代码，碰到了这样的一个实现：\nreturn new Promise((resolve, reject) =\u003e { this.pendingResolvers.get(key).push([resolve, reject]); }); 它看起来没什么特别的地方。但我突然意识到，我以前可能其实根本没搞懂 Promise 是怎么“兑现承诺“的。","完整代码#完整代码":" // 有一个 requestFn(keys: string[]): Promise\u003cRecord\u003cstring, any\u003e\u003e 方法，每次可以批量获取多个 key 对应的数据（如批量接口：传一组 key，返回一个 key-value 对）。 // 用户可以通过 get(key: string): Promise\u003cany\u003e 来请求某个 key 的数据： // 如果当前有同样的 key 正在请求中，应复用同一个 promise。意思是： // 要使用同一个promise，对每个请求都返回这个promise的[resolve, reject]。 // 不同的 key 会被合并成一个批量请求，延迟 50ms 发出。 // 有 cancel(key: string) 方法，用于取消某个 key 的请求（如果它还没发出或者还在 pending）。 // 有缓存：如果某个 key 的数据已请求成功，应缓存，后续请求直接从缓存中取值。 class BatchRequestManager { constructor(batchRequestFn) { this.batchRequestFn = batchRequestFn; this.delay = 50; // 延迟时间 this.keysToFetch = new Set(); // 收集请求的 key this.pendingResolvers = new Map(); // 收集请求的key对应的promise，key -\u003e多个 Promise[resolve,reject] this.cache = new Map(); // 缓存结果 key -\u003e value this.timer = null; // 防抖 } /** * 获取某个 key 的数据，合并请求、去重、带缓存 * @param {string} key * @returns {Promise\u003cany\u003e} */ get(key) { // 复用缓存 if (this.cache.has(key)) { return Promise.resolve(this.cache.get(key)); // 从缓存中获取 } // 复用请求队列 if (this.pendingResolvers.has(key)) { return new Promise((resolve, reject) =\u003e { this.pendingResolvers.get(key).push([resolve, reject]); }); } // 新的请求 this.keysToFetch.add(key); this.pendingResolvers.set(key, []); const promise = new Promise((resolve, reject) =\u003e { this.pendingResolvers.get(key).push([resolve, reject]); }); if (!this.timer) this.timer = setTimeout(() =\u003e this._flush(), this.delay); // 启动定时器 return promise; } /** * 取消某个 key 的请求 * @param {string} key */ cancel(key) {...} /** * 批量请求 * @private */ async _flush() { const keys = Array.from(this.keysToFetch); this.keysToFetch.clear(); this.timer = null; let results; try { results = await this.batchRequestFn(keys); } catch (err) { // 出现任何失败，都会将所有的请求 reject for (const key of keys) { // 找到每个key的多个[resolve, reject]，全部 reject const resolvers = this.pendingResolvers.get(key) || []; for (const [_, reject] of resolvers) { reject(err); } this.pendingResolvers.delete(key); } return; } // 请求成功，分别 resolve for (const key of keys) { if (key in results) { const value = results[key]; this.cache.set(key, value); // 这里每个key都有多个[resolve, reject]，我们全部 resolve const resolvers = this.pendingResolvers.get(key) || []; for (const [resolve] of resolvers) { resolve(value); } } else { const resolvers = this.pendingResolvers.get(key) || []; for (const [_, reject] of resolvers) { reject(new Error(`no data for key: ${key}`)); } } this.pendingResolvers.delete(key); } } } "},"title":"关于Promise的一些探究"},"/myblog/react-fiber-reconciliation/":{"data":{"":" 摘自自己的前端笔记","fiber-的结构#Fiber 的结构":"一个 Fiber（文章里用斜体Fiber表示）是一个简单的 JavaScript 对象。它代表 React 元素或 DOM 树的一个节点。它是一个工作单位。相比之下，Fiber 是 React Fiber 的协调器。\n在第一次渲染时，React 会浏览每个 React 元素并创建一棵 fibers 树。虽然我们称之为树，但 React Fiber 创建了一个节点的链表，其中每个节点都是一个 fiber。 并且在父、子和兄弟姐妹之间存在着一种关系。React 使用一个 return 键来指向父节点，任何一个子 fiber 在完成工作后都应该返回该节点；React也有指向子节点、兄弟节点的指针。\nFiber节点的结构如下：\nfunction FiberNode( this: $FlowFixMe, tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { // 基本属性 this.tag = tag; // 描述此Fiber的启动模式的值（LegacyRoot = 0; ConcurrentRoot = 1） this.key = key; // React key this.elementType = null; // 描述React元素的类型。例如，对于JSX\u003cApp /\u003e，elementType是App this.type = null; // 组件类型 this.stateNode = null; // 对于类组件，这是类的实例；对于DOM元素，它是对应的DOM节点。 // Fiber链接 this.return = null; // 指向父Fiber this.child = null; // 指向第一个子Fiber this.sibling = null; // 指向其兄弟Fiber this.index = 0; // 子Fiber中的索引位置 this.ref = null; // 如果组件上有ref属性，则该属性指向它 this.refCleanup = null; // 如果组件上的ref属性在更新中被删除或更改，此字段会用于追踪需要清理的旧ref // Props \u0026 State this.pendingProps = pendingProps; // 正在等待处理的新props this.memoizedProps = null; // 上一次渲染时的props this.updateQueue = null; // 一个队列，包含了该Fiber上的状态更新和副作用 this.memoizedState = null; // 上一次渲染时的state this.dependencies = null; // 该Fiber订阅的上下文或其他资源的描述 // 工作模式 this.mode = mode; // 描述Fiber工作模式的标志（例如Concurrent模式、Blocking模式等）。 // Effects this.flags = NoFlags; // 描述该Fiber发生的副作用的标志（十六进制的标识） this.subtreeFlags = NoFlags; // 描述该Fiber子树中发生的副作用的标志（十六进制的标识） this.deletions = null; // 在commit阶段要删除的子Fiber数组 this.lanes = NoLanes; // 与React的并发模式有关的调度概念。 this.childLanes = NoLanes; // 与React的并发模式有关的调度概念。 this.alternate = null; // Current Tree和Work-in-progress (WIP) Tree的互相指向对方tree里的对应单元 // 如果启用了性能分析 if (enableProfilerTimer) { // …… } // 开发模式中 if (__DEV__) { // …… } } 可以看到每个节点都有自己的属性、元素类型、父子兄弟关系、状态和副作用。\n为什么fiber比之前的递归DOM更快？就是因为使用flags标记当前节点和子树的副作用类型，减少节点遍历。并且调和过程可被中断。","参考资料#参考资料":"fiber架构的原理和工作模式\nfiber简介（机翻）","建立阶段#建立阶段":"建立阶段确定哪些部分的UI需要更新，会比较当前的树current和正在工作的树workInProgress。\n当前被刷新用来渲染用户界面的树，被称为 current，它用来渲染当前用户界面。每当有更新时，Fiber 会建立一个 workInProgress 树，它是由 React 元素中已经更新数据创建的。React 在这个 workInProgress 树上执行工作，并在下次渲染时使用这个更新的树。一旦这个 workInProgress 树被渲染到用户界面上，它就成为 current 树。\n两个阶段：\n判断fiber是否要更新，创建与标记更新节点 收集副作用列表 更新渲染树 Fiber树遍历 最终的fiber树：\n最终结果 ","更新阶段#更新阶段":"对于每次更新，它都会建立一个 workInProgress 树。它从根 fiber 开始，遍历该树，直到叶子节点。与初始渲染阶段不同，它不会为每个 React 元素创建一个新的 fiber 。它只是为该 React 元素使用预先存在的 fiber ，并在更新阶段合并来自更新元素的新数据和 props。\nReact Fiber 将更新划分为工作单元。它可以为每个工作单元分配优先级，并有能力暂停、重用或在不需要时中止工作单元。 React Fiber 将工作分为多个工作单位，也就是 fiber 。它将工作安排在多个框架中，并使用来自 requestIdleCallback 的 deadline 。每个更新都有其优先级的定义，如动画，或用户输入的优先级高于从获取的数据中渲染项目的列表。Fiber 使用 requestAnimationFrame 来处理优先级较高的更新，使用 requestIdleCallback 处理优先级较低的更新。因此，在调度工作时，Fiber 检查当前更新的优先级和 deadline （帧结束后的自由时间）。\n如果优先级高于待处理的工作，或者没有 截止日期 或者截止日期尚未到达，Fiber 可以在一帧之后安排多个工作单元。而下一组工作单元会被带到更多的帧上。这就是使 Fiber 有可能暂停、重用和中止工作单元的原因。","核心#核心":"Fiber 的核心特性是中断和恢复，这一特性大幅增强了 React 的并发性和响应性。\nReact判断Fiber是否有足够时间完成任务的机制是：检查任务优先级（用户输入/动画\u003e非关键内容\u003e懒加载）\n中断 可中断的能力是React并发模式（Concurrent Mode）的核心，这种能力使得React可以优先处理高优先级的更新，而推迟低优先级的更新。（很复杂，但是类似OS的中断/挂起，会保存上下文等等）\n增量渲染 React将渲染任务分成每个Fiber单元，包含组件状态、生命周期、DOM操作等信息。React按照Fiber的优先级逐一执行","渲染阶段#渲染阶段":"开始 workLoop会判断每个fiber是否有待处理的工作，没有则跳过已经处理过的fiber。\n如果有子 fiber ，beginWork函数返回子 fiber ，如果没有子 fiber 则返回空。函数 performUnitOfWork 持续迭代并调用子 fiber ，直到叶节点到达。在叶子节点的情况下，beginWork 返回 null，因为没有任何子节点，performUnitOfWork 函数调用 completeUnitOfWork 函数。现在让我们看看完善阶段。\n完善 这个 completeUnitOfWork 函数通过调用一个 completeWork 函数来完成当前单位的工作。如果有的话，completeUnitOfWork 会返回一个同级的 fiber 来执行下一个工作单元，如果没有工作的话，则会完成 return(parent) fiber 。这将一直持续到返回值为空，也就是说，直到它到达根节点。和 beginWork 一样，completeWork 也是一个发生实际工作的函数，而 completeUnitOfWork 是用于迭代的。\n渲染阶段的结果会产生一个效果列表（副作用）。这些效果就像插入、更新或删除宿主组件的节点，或调用类组件节点的生命周期方法。这些 fiber 被标记为各自的效果标签。\n提交 在这里，workInProgress 树成为 current 树，因为它被用来渲染 UI。实际的 DOM 更新，如插入、更新、删除，以及对生命周期方法的调用或者更新相对应的引用 —— 发生在 effect 列表中的节点上。","简要概括#简要概括":"协调算法是 React 在更新 UI 时的工作流程，目的是确定哪些部分的UI需要更新。React Fiber是React 16引入的新的协调算法。\n在 React 16 之前，组件树更新是通过递归方式进行的，称为堆栈调和（Stack Reconciliation），这种方式一旦开始无法中断，直到遍历完整个组件树。这种机制在处理大量数据或复杂视图时，可能导致主线程阻塞，从而影响应用对用户输入和其他高优先级任务的响应。\nReact Fiber 是对协调器的重写，完全向后兼容。React 的新协调算法被称为 Fiber Reconciler，主要目标是增量渲染，优化 UI 动画、手势和用户交互响应性。它允许将工作分为多个块，并将渲染分为多个帧。此外，Fiber 引入了优先级、暂停、复用和中止工作的能力。Fiber 可视为 React 自定义的带链接关系的DOM 树，每个 Fiber 代表一个工作单元，React 可根据剩余时间决定是否完成该工作，必要时可中断并恢复。"},"title":"React Fiber流程简介"},"/myblog/useless-gdb-cheatsheet/":{"data":{"":"","参考#参考":"基本命令 1. disassemble 输出当前函数的汇编代码\n默认为AT\u0026T格式，用set disassembly-flavor intel来改为Intel汇编格式\n可以用layout asm，在上方代码区显示汇编码\n2. run 用run（简写r）开始执行程序，直到遇到断点停止。也可用Ctrl+C手动中断。执行过程再次使用run即可重启程序。\n3. continue 触发断点或者用Ctrl+C中断后，用continue（简写c）继续，程序会执行直到遇到另一个断点。\n4. break 用break（简写b）添加断点。\n## 在函数名为functionname的入口处添加一个断点（比如main） break functionname ## 在当前文件行号为LineNo处添加一个断点 break LineNo ## 在filename文件行号为LineNo处添加一个断点 break filename:LineNo 5. tbreak tbreak和break用法相同，不过用此命令添加的断点触发一次之后即被删除。\n6. info break/enable/disable/delete info break查看添加的所有断点\nenable/disable + 断点编号可启用/禁用断点。若不加编号，默认对所有断点进行处理\ndelete + 断点编号永久删除断点。若不加编号，默认对所有断点进行处理\n7. backtrace/frame backtrace (bt)查看当前线程的调用堆栈\nframe + 堆栈编号可切换到其他堆栈\n8. list list (l)查看当前断点附近的代码。一般显示断点前后10行代码\nlist + [加号] 向下显示10行代码， list+[减号] 向上显示10行代码\n9. print/ptype print print (p) 可方便输出/修改变量的值\n同时支持输出表达式（解引用*，算术+-*/，打印错误码对应文字信息strerror(errno) ）\nprint variable = value 即可修改变量的值\nprint /format variable 指定输出格式\nptype ptype variable 输出变量类型（支持结构体）\n10. info/thread info用于查看各种信息，比如\ninfo thread 查看所有线程\ninfo args 查看当前函数的参数值\nthread + 线程编号 切换到指定线程\n11. next/step/until/finish/return/jump next (n)跳到下一行（单步步过step over，遵循代码逻辑）\nstep (s)会进入函数内部（单步步入step into）\nuntil (u) + \u003clineno\u003e 直接执行到行数停止\nreturn \u003cvalue\u003e 直接让函数用value返回值返回\njump \u003clineno/location\u003e 直接跳到行数或者函数地址（不停止，需要自行设置断点）\nGDB空行直接回车默认为执行最近一次的命令。\n12. set args/show args 在使用run命令之前，使用set args命令行参数来指定.\n可以使用文件，也可以直接輸入參數。有空格可以用雙引號包裹起來。\n清除参数，用set args不加参数即可\n13. watch/display watch监视一个变量或者一段内存，如果发生变化就会中断。会产生一个watch point 观察点（数据断点）\ndisplay监视变量或者内存值，每次 gdb 中断下来都会自动输出这些被监视变量或内存的值\nnfo display查看当前已经监视了哪些值，使用delete display清除全部被监视的变量，使用delete display + 编号移除对指定变量的监视\n14. dir gcc/g++编译出来的可执行程序并不包含完整源码，在不同环境里调试时可能不能匹配，dir可以让被调试的可执行程序匹配源代码\n# 加一个源文件路径到当前路径的前面,指定多个路径为源码目录，可以使用引号”:” dir SourcePath1:SourcePath2:SourcePath show dir可以查看当前设置的源码路径\ndir不加参数则初始化搜索路径为空\n参考 GDB常用命令详解——利用GDB调试Redis\nGDB 备忘清单 \u0026 gdb cheatsheet \u0026 Quick Reference\nCheatSheet PDF","基本命令#基本命令":""},"title":"看了也不会的GDB CheatSheet"}}